
<h1 class="title">Tutoriel Ruby on Rails </h1>


<h1 class="subtitle"> Apprendre Rails par l'exemple</h1>


<h2 class="author">Michael Hartl</h2>


<!-- CONTENT -->

<!-- AVANT PROPOS -->


<div id="top"></div>


<h1 class="chapitre"><a id="sec:4" href="rails-flavored-ruby#top" class="heading"><span class="number">chapitre 4</span> Rails au goût Ruby</a></h1>


<p>Fondé sur les exemples du <a class="ref" href="static-pages#top">chapitre&nbsp;3</a>, ce chapitre explore quelques éléments Ruby importants pour Rails. Ruby est un vaste langage, mais heureusement les sous-ensemble nécessaire pour être productif en tant que développeur Rails est relativement limité. Plus encore, ce sous-ensemble est  <em>différent</em> de l'approche habituelle de l'apprentissage de Ruby, ce pourquoi, si votre but est de construire des applications web dynamique, je recommande d'apprendre Rails d'abord, en picorant quelques éléments Ruby chemin faisant. Pour devenir un <em>expert</em> Rails, vous avez besoin de comprendre Ruby plus profondément, et ce livre vous donne de solides fondations sur lesquelles développer cette expertise more. Comme indiqué à la <a class="ref" href="beginning#sec:comments_for_various_readers">section&nbsp;1.1.1</a>, après avoir achevé ce <em>Tutoriel Rails</em> je vous suggère de lire une livre de pur Ruby tel que  <a href="http://www.amazon.com/gp/product/1430223634?ie=UTF8&amp;tag=httpwwwrailst-20&amp;linkCode=as2&amp;camp=1789&amp;creative=9325&amp;creativeASIN=1430223634"><em>Beginning Ruby</em></a>, <a href="http://www.amazon.com/gp/product/1933988657?ie=UTF8&amp;tag=httpwwwrailst-20&amp;linkCode=as2&amp;camp=1789&amp;creative=9325&amp;creativeASIN=1933988657"><em>The Well-Grounded Rubyist</em></a> ou <a href="http://www.amazon.com/gp/product/B000P28V8Q?ie=UTF8&amp;tag=httpwwwrailst-20&amp;linkCode=as2&amp;camp=1789&amp;creative=9325&amp;creativeASIN=B000P28V8Q"><em>The Ruby Way</em></a>.</p>

<p>Ce chapitre couvre beaucoup de points, et il sera possible de ne pas les saisir tous du premier coup. J'y reviendrai fréquemment au cours des prochains chapitres.</p>

<div class="label" id="sec:motivation"></div>


<h2><a id="sec:4.1" href="rails-flavored-ruby#sec:motivation" class="heading"><span class="number">4.1</span> Motivation</a></h2>


<p>Comme nous l'avons vu dans le dernier chapitre, il est possible de développer le squelette d'une application Rails, et même de commencer à la tester, avec essentiellement aucune connaissance du langage Ruby. Nous avons fait cela en nous appuyant sur code de contrôleur et de test généré automatiquement et en suivant les exemples trouvés. Cette situation ne peut tout de même pas durer éternellement, cependant, eet nous allons ouvrir ce chapitre avec un certain nombre d'addition au site qui va nous conduire à nous confronter à nos limites en Ruby.</p>

<div class="label" id="sec:title_helper"></div>


<h3><a id="sec:4.1.1" href="rails-flavored-ruby#sec:title_helper" class="heading"><span class="number">4.1.1</span> Un «&nbsp;helper&nbsp;» de titre</a></h3>


<p>Quand nous avons vu la dernière fois notre application, nous avions juste actualisé les pages statiques classiques pour utiliser les <em>layouts</em> Rails pour éliminer les redondances de codes dans nos vues (<a class="ref" href="rails-flavored-ruby#code:application_layout_redux">extrait&nbsp;4.1</a>).</p>

<div class="label" id="code:application_layout_redux"></div>


<div class="codelisting">
<div class="listing"><span class="header">Extrait 4.1.</span> <span class="description">Le layout du site de l'application exemple. <br /> <code>app/views/layouts/application.html.erb</code></span>       
</div>
<div class="code"><div class="highlight"><pre><span class="cp">&lt;!DOCTYPE html&gt;</span>
<span class="nt">&lt;html&gt;</span>
  <span class="nt">&lt;head&gt;</span>
    <span class="nt">&lt;title&gt;</span>Simple App du Tutoriel Ruby on Rails | <span class="cp">&lt;%=</span> <span class="vi">@title</span> <span class="cp">%&gt;</span><span class="nt">&lt;/title&gt;</span>
    <span class="cp">&lt;%=</span> <span class="n">csrf_meta_tag</span> <span class="cp">%&gt;</span>
  <span class="nt">&lt;/head&gt;</span>
  <span class="nt">&lt;body&gt;</span>
    <span class="cp">&lt;%=</span> <span class="k">yield</span> <span class="cp">%&gt;</span>
  <span class="nt">&lt;/body&gt;</span>
<span class="nt">&lt;/html&gt;</span>
</pre></div>
</div></div>


<p>Ce layout fonctionne bien, mais il contient une partie qui pourrait être encore améliorée. Rappelez-vous que la ligne de titre&nbsp;:</p>

<div class="code"><div class="highlight"><pre>Simple App du Tutoriel Ruby on Rails | <span class="cp">&lt;%=</span> <span class="vi">@title</span> <span class="cp">%&gt;</span>
</pre></div>
</div>


<p>… s'appuie sur la définition de <code>@title</code> dans les actions, telle que&nbsp;:</p>

<div class="code"><div class="highlight"><pre><span class="k">class</span> <span class="nc">PagesController</span> <span class="o">&lt;</span> <span class="no">ApplicationController</span>

  <span class="k">def</span> <span class="nf">home</span>
    <span class="vi">@title</span> <span class="o">=</span> <span class="s2">&quot;Home&quot;</span>
  <span class="k">end</span>
  <span class="o">.</span>
  <span class="o">.</span>
  <span class="o">.</span>
</pre></div>
</div>


<p>Mais que se passe-t-il si nous ne définissons pas la variable <code>@title</code>&nbsp;? C'est une bonne convention graphique d'avoir toujours une <em>base de titre</em> sur chaque page, avec une variable optionnelle si on a besoin d'être plus précis. Nous avons <em>presque</em> terminé cela avec notre layout courant, avec une combien&nbsp;: comme vous pouvez le voir si vous supprimez la déclaration de <code>@title</code> dans l'une des actions, en l'absence de la variable <code>@title</code> le titre apparait comme suit&nbsp;:</p>

<div class="code"><div class="highlight"><pre>Simple App du Tutoriel Ruby on Rails | 
</pre></div>
</div>


<p>En d'autres termes, il y a une base de titre satisfaisante, mais il y a aussi un caractère de barre verticale, <code>|</code>, à la fin de cette base de titre.</p>

<p>Une façon courante de traiter ce cas est de définir un <em>helper</em> (un «&nbsp;<em>aideur</em>&nbsp;»), qui eest une fonction conçue pour être utilisée avec les vues. Définissons un <em>helper</em> titre  qui retourne une base de titre, &ldquo;&nbsp;Simple App du Tutoriel Ruby on Rails&nbsp;&rdquo;, si aucune variable <code>@title</code> n'est définie, et ajoute une barre verticale dans le cas où cette variable serait définie (<a class="ref" href="rails-flavored-ruby#code:title_helper">extrait&nbsp;4.2</a>).<sup class="footnote" id="fnref:4.1"><a href="#fn:4.1">1</a></sup></p>

<div class="label" id="code:title_helper"></div>


<div class="codelisting">
<div class="listing"><span class="header">Extrait 4.2.</span> <span class="description">Définir un <em>helper</em> de titre. <br /> <code>app/helpers/application_helper.rb</code></span>       
</div>
<div class="code"><div class="highlight"><pre><span class="k">module</span> <span class="nn">ApplicationHelper</span>

  <span class="c1"># Retourner un titre basé sur la page.</span>
  <span class="k">def</span> <span class="nf">title</span>
    <span class="n">base_title</span> <span class="o">=</span> <span class="s2">&quot;Simple App du Tutoriel Ruby on Rails&quot;</span>
    <span class="k">if</span> <span class="vi">@title</span><span class="o">.</span><span class="n">nil?</span>
      <span class="n">base_title</span>
    <span class="k">else</span>
      <span class="s2">&quot;</span><span class="si">#{</span><span class="n">base_title</span><span class="si">}</span><span class="s2"> | </span><span class="si">#{</span><span class="vi">@title</span><span class="si">}</span><span class="s2">&quot;</span>
    <span class="k">end</span>
  <span class="k">end</span>
<span class="k">end</span>
</pre></div>
</div></div>


<p>Cela peut sembler plus simple aux yeux d'un développeur Rails expérimenté, mais ce code est en réalité <em>plein</em> de nouvelles idées sur Ruby&nbsp;: modules, commentaires, déclaration de variable locale, booléens, contrôle de flux, interpolation de chaine, et retour de valeur. Nous allons couvrir chacune de ces idées dans ce chapitre.</p>

<p>Maintenant que nous avons un <em>helper</em>, nous pouvons l'utiliser pour simplifier notre layout en remplaçant…</p>

<div class="code"><div class="highlight"><pre><span class="nt">&lt;title&gt;</span>Simple App du Tutoriel Ruby on Rails | <span class="cp">&lt;%=</span> <span class="vi">@title</span> <span class="cp">%&gt;</span><span class="nt">&lt;/title&gt;</span>
</pre></div>
</div>


<p>… par…</p>

<div class="code"><div class="highlight"><pre><span class="nt">&lt;title&gt;</span><span class="cp">&lt;%=</span> <span class="n">title</span> <span class="cp">%&gt;</span><span class="nt">&lt;/title&gt;</span>
</pre></div>
</div>


<p>… comme on peut le voir dans l'<a class="ref" href="rails-flavored-ruby#code:application_layout_full_title">extrait&nbsp;4.3</a>.
Notez en particulier le basculement de la variable d'instance <code>@title</code> vers la méthode de l'<em>helper</em> <code>title</code> (sans le signe arobase, <code>@</code>). En utilisant Autotest ou <code>rspec spec/</code>, vous devriez pouvoir vérifier que les tests du <a class="ref" href="static-pages#top">chapitre&nbsp;3</a> réussissent toujours.</p>

<div class="label" id="code:application_layout_full_title"></div>


<div class="codelisting">
<div class="listing"><span class="header">Extrait 4.3.</span> <span class="description">Le layout du site de l'aplication exemple. <br /> <code>app/views/layouts/application.html.erb</code></span>       
</div>
<div class="code"><div class="highlight"><pre><span class="cp">&lt;!DOCTYPE html&gt;</span>
<span class="nt">&lt;html&gt;</span>
  <span class="nt">&lt;head&gt;</span>
    <span class="nt">&lt;title&gt;</span><span class="cp">&lt;%=</span> <span class="n">title</span> <span class="cp">%&gt;</span><span class="nt">&lt;/title&gt;</span>
    <span class="cp">&lt;%=</span> <span class="n">csrf_meta_tag</span> <span class="cp">%&gt;</span>
  <span class="nt">&lt;/head&gt;</span>
  <span class="nt">&lt;body&gt;</span>
    <span class="cp">&lt;%=</span> <span class="k">yield</span> <span class="cp">%&gt;</span>
  <span class="nt">&lt;/body&gt;</span>
<span class="nt">&lt;/html&gt;</span>
</pre></div>
</div></div>




<div class="label" id="sec:cascading_style_sheets"></div>


<h3><a id="sec:4.1.2" href="rails-flavored-ruby#sec:cascading_style_sheets" class="heading"><span class="number">4.1.2</span> Feuilles de styles en cascade (CCS &mdash;&nbsp;Cascading Style Sheets)</a></h3>


<p>Il y a une seconde addition à notre site qui peut sembler simple mais introduit de nouveaux concepts Ruby&nbsp;: l'inclusion de feuilles de styles dans le layout de notre site. Bien que ce soit un livre sur le développement web, pas sur le design web, nous utiliserons les feuilles de styles en cascade (CSS) pour donner un minimum de style à notre application exemple, et nous utiliserons pour cela le framework <a href="http://www.blueprintcss.org/">Blueprint CSS</a>.</p>

<p>Pour commencer, <a href="http://github.com/joshuaclayton/blueprint-css/zipball/master">téléchargez le dernier Blueprint CSS</a> (pour la simplicité, je présuppose que vous téléchargez Blueprint dans un dossier <code>Downloads</code>, mais utilisez le dossier que vous voulez). En utilisant soit le mode en ligne de commande soit un outil graphique, copiez le dossier de Blueprint CSS <code>blueprint</code> dans le dossier <code>public/stylesheets</code> de votre application exemple, un dossier spécial où Rails conserve les feuilles de styles. Sur mon Mac, la commande ressemble à celle-ci, mais vos détails peuvent varier&nbsp;:</p>

<div class="code"><div class="highlight"><pre><span class="nv">$ </span>cp -r ~/Downloads/joshuaclayton-blueprint-css-&lt;version number&gt;/blueprint <span class="se">\</span>
&gt; public/stylesheets/
</pre></div>
</div>

<p>Ici <code>cp</code> est la commande Unix pour <em>copier</em>, et le drapeau <code>-r</code> copie récursivement (nécessaire pour copier tous les dossiers). (Comme mentionné brièvement à la <a class="ref" href="static-pages#sec:autotest">section&nbsp;3.2.1.1</a>, le tilde <tt class="verb">~</tt> signifie &ldquo;dossier home&rdquo; en Unix.) <em>Note&nbsp;:</em> vous ne devriez <em>pas</em> coller le signe &nbsp;<tt class="verb">&gt;</tt> dans votre terminal. Si vous collez la première ligne avec ce signe et pressez la touche retour-chariot, vous verrez <tt class="verb">&gt;</tt> indicant une continuation de ligne. Vous devrez alors coller dans la seconde ligne et presser la touche Retour-chariot une nouvelle fois pour exécuter la commande. Notez aussi que vous aurez à renseigner le numéro de version à la main, puisqu'il change à chaque actualisation de Blueprint. Enfin, assurez-vous de <em>ne pas</em> taper&nbsp;:</p>

<div class="code"><div class="highlight"><pre><span class="nv">$ </span>cp -r ~/Downloads/joshuaclayton-blueprint-css-&lt;version number&gt;/blueprint/ <span class="se">\</span>
&gt; public/stylesheets/
</pre></div>
</div>


<p>… qui a une balance («&nbsp;/&nbsp;») à la fin <code>&hellip;/blueprint/</code>. Cela déposerait le <em>contenu</em> du dossier Blueprint dans le dossier <code>public/stylesheets</code> au lieu de déplacer le dossier lui-même.</p>

<p>Une fois que les feuilles de styles se trouvent dans le bon dossier, Rails fournit un <em>helper</em> pour les inclure dans nos pages en utilisant du Ruby embarqué (<a class="ref" href="rails-flavored-ruby#code:layout_with_stylesheets">extrait&nbsp;4.4</a>).</p>

<div class="label" id="code:layout_with_stylesheets"></div>


<div class="codelisting">
<div class="listing"><span class="header">Extrait 4.4.</span> <span class="description">Ajout de feuilles de styles au layout de l'application exemple. <br /> <code>app/views/layouts/application.html.erb</code></span>       
</div>
<div class="code"><div class="highlight"><pre><span class="cp">&lt;!DOCTYPE html&gt;</span>
<span class="nt">&lt;html&gt;</span>
  <span class="nt">&lt;head&gt;</span>
    <span class="nt">&lt;title&gt;</span><span class="cp">&lt;%=</span> <span class="n">title</span> <span class="cp">%&gt;</span><span class="nt">&lt;/title&gt;</span>
    <span class="cp">&lt;%=</span> <span class="n">csrf_meta_tag</span> <span class="cp">%&gt;</span>
    <span class="cp">&lt;%=</span> <span class="n">stylesheet_link_tag</span> <span class="s1">&#39;blueprint/screen&#39;</span><span class="p">,</span> <span class="ss">:media</span> <span class="o">=&gt;</span> <span class="s1">&#39;screen&#39;</span> <span class="cp">%&gt;</span>
    <span class="cp">&lt;%=</span> <span class="n">stylesheet_link_tag</span> <span class="s1">&#39;blueprint/print&#39;</span><span class="p">,</span>  <span class="ss">:media</span> <span class="o">=&gt;</span> <span class="s1">&#39;print&#39;</span> <span class="cp">%&gt;</span>
  <span class="nt">&lt;/head&gt;</span>
  <span class="nt">&lt;body&gt;</span>
    <span class="cp">&lt;%=</span> <span class="k">yield</span> <span class="cp">%&gt;</span>
  <span class="nt">&lt;/body&gt;</span>
<span class="nt">&lt;/html&gt;</span>
</pre></div>
</div></div>


<p>Concentrons-nous sur les nouvelles lignes&nbsp;:</p>

<div class="code"><div class="highlight"><pre><span class="cp">&lt;%=</span> <span class="n">stylesheet_link_tag</span> <span class="s1">&#39;blueprint/screen&#39;</span><span class="p">,</span> <span class="ss">:media</span> <span class="o">=&gt;</span> <span class="s1">&#39;screen&#39;</span> <span class="cp">%&gt;</span>
<span class="cp">&lt;%=</span> <span class="n">stylesheet_link_tag</span> <span class="s1">&#39;blueprint/print&#39;</span><span class="p">,</span>  <span class="ss">:media</span> <span class="o">=&gt;</span> <span class="s1">&#39;print&#39;</span> <span class="cp">%&gt;</span>
</pre></div>
</div>


<p>Elles utilisent l'<em>helper</em> Rails intégré <code>stylesheet_link_tag</code>, détaillé dans l'API Rails.<sup class="footnote" id="fnref:4.2"><a href="#fn:4.2">2</a></sup> La première ligne <code>stylesheet_link_tag</code> inclue la feuille de style <code>blueprint/screen.css</code> pour l'écran (par exemple le moniteur de votre ordinateur), et la seconde inclue <code>blueprint/print.css</code> pour l'impression (l'helper ajoute automatiquement l'extension <code>.css</code> au nom de fichier s'il est absent, donc je l'ai omis pour la brièveté). Comme pour l'helper de titre, pour un développeur Rails expérimenté ces lignes semblent vraiment simples, mais elles contiennent au moins quatre nouvelles idées&nbsp;: les méthodes Rails intégrées, l'invocation de méthode avec l'omission des parenthèses, les symboles et les tableaux hash. Ce chapitre couvre aussi ces nouvelles idée (nous verrons le code HTML produit par ces feuilles de styles dans l'<a class="ref" href="rails-flavored-ruby#code:css_source">extrait&nbsp;4.6</a> de la <a class="ref" href="rails-flavored-ruby#sec:css_revisited">section&nbsp;4.3.4</a>).</p>

<p>En passant, notons que les nouvelles feuilles de styles ne changent pas l'aspect de notre site, mais c'est seulement un départ (<a class="ref" href="rails-flavored-ruby#fig:home_with_stylesheet">illustration&nbsp;4.1</a>. Nous travaillerons sur cette fondation au <a class="ref" href="filling-in-the-layout#top">chapitre&nbsp;5</a>.<sup class="footnote" id="fnref:4.3"><a href="#fn:4.3">3</a></sup></p>

<div class="label" id="fig:home_with_stylesheet"></div>


<div class="figure"><div class="center"><span class="graphic"><img src="/images/figures/home_with_stylesheet.png" alt="home_with_stylesheet" /></span></div><div class="caption"><span class="header">Illustration 4.1: </span><span class="description">La page d'accueil avec les nouvelles feuilles de styles Blueprint.&nbsp;<a href="http://railstutorial.org/images/figures/home_with_stylesheet-full.png">(full size)</a></span></div></div>




<div class="label" id="sec:strings_and_methods"></div>


<h2><a id="sec:4.2" href="rails-flavored-ruby#sec:strings_and_methods" class="heading"><span class="number">4.2</span> Chaines de caractère et méthodes</a></h2>


<p>Notre outil principal pour apprendre Ruby sera la <em>console Rails </em>, qui est un outil en ligne de commande pour intéragir avec les applications Rails. La console elle-même est construite au sommet  which is a command-line tool for interacting with Rails applications. [(The console itself is built on top of interactive Ruby)(La console elle-même est construite au sommet de l'intéractivité de Ruby)] (<code>irb</code>), et ainsi a accès à toute la puissance de Ruby (comme nous le verrons à la <a class="ref" href="rails-flavored-ruby#sec:a_controller_class">section&nbsp;4.4.4</a>, la console a aussi accès à l'environnement Rails). Démarrez la console en ligne de commande comme suit&nbsp;:<sup class="footnote" id="fnref:4.4"><a href="#fn:4.4">4</a></sup></p>

<div class="code"><div class="highlight"><pre><span class="go">$ rails console</span>
<span class="go">Loading development environment (Rails 3.0.7)</span>
<span class="gp">&gt;&gt; </span>
</pre></div>
</div>


<p>Par défaut, la console commence en <em>environnement de développement</em>, qui est l'un des trois environnements séparés définis par Rails (les deux autres environnement sont l'environnement de <em>test</em> et l'environnement de <em>production</em>). Cette distinction ne sera pas importante dans ce chapitre&nbsp;; nous en apprendrons plus sur les environemments à la <a class="ref" href="modeling-and-viewing-users-one#sec:rails_environments">section&nbsp;6.3.1</a>.</p>

<p>La console est un puissant outil d'apprentissage, et vous devrez toujours vous sentir libre de l'explorer &mdash;&nbsp;ne vous inquiétez pas, vous ne casserez (probablement) rien. En utilisant la console, tapez Ctrl-C si vous vous retrouvez coincé, ou Ctrl-D pour quitter cette console.</p>

<p>Tout au long de ce chapitre, vous pourrez trouver utile de consulter l'API Ruby.<sup class="footnote" id="fnref:4.5"><a href="#fn:4.5">5</a></sup> Cet API est emballée (peut-être même <em>trop</em> emballée) avec des informations&nbsp;; par exemple, pour en apprendre plus sur les chaines de caractères Ruby vous pouvez consulter l'entrée de l'API Ruby pour la classe <code>String</code>.</p>

<div class="label" id="sec:comments"></div>


<h3><a id="sec:4.2.1" href="rails-flavored-ruby#sec:comments" class="heading"><span class="number">4.2.1</span> Commentaires</a></h3>


<p>Les <em>commentaires</em> Ruby commencent par le signe dièse&nbsp;<code>#</code> et s'étendent jusqu'à la fin de la ligne. Ruby (et donc Rails) ignore les commentaires, mais ils sont utiles pour les lecteurs humains (à commencer, souvent, par l'auteur original&nbsp;!). Dans le code&nbsp;:</p>

<div class="code"><div class="highlight"><pre>  <span class="c1"># Retourne un titre propre à la page.</span>
  <span class="k">def</span> <span class="nf">title</span>
  <span class="o">.</span>
  <span class="o">.</span>
  <span class="o">.</span>
</pre></div>
</div>


<p>… la première ligne est un commentaire indiquant le but de la définition de fonction qui suit.</p>

<p>D'ordinaire, vous n'incluez pas de commentaires dans les sessions de console, mais dans le but de cet apprentissage, j'en incluerai dans ce qui suit, comme cela&nbsp;:</p>

<div class="code"><div class="highlight"><pre><span class="go">$ rails console</span>
<span class="gp">&gt;&gt; </span><span class="mi">17</span> <span class="o">+</span> <span class="mi">42</span>   <span class="c1"># Addition d'entiers</span>
<span class="go">=&gt; 59</span>
</pre></div>
</div>


<p>Si vous poursuive cette section en tapant ou en copiant-collant les commandes dans votre propre console, vous pouvez bien sûr omettre ces commentaires&nbsp;; la console les ignorera de toute façon.</p>

<div class="label" id="sec:strings"></div>


<h3><a id="sec:4.2.2" href="rails-flavored-ruby#sec:strings" class="heading"><span class="number">4.2.2</span> Chaines de caractères</a></h3>


<p><em>la chaine de caractères</em> (<em>Strings</em>) est probablement la structure de données la plus importante des applications web, puisque les pages web consistent en fin de compte en des chaines de texte envoyées par le serveur aux navigateurs. Commençons à explorer ces chaines de caractères avec la console, cette fois en commençant avec <code>rails&nbsp;c</code>, qui est un raccourci pour la commande <code>rails console</code>&nbsp;:</p>

<div class="code"><div class="highlight"><pre><span class="go">$ rails c</span>
<span class="gp">&gt;&gt; </span><span class="s2">&quot;&quot;</span>         <span class="c1"># Une chaine vide</span>
<span class="go">=&gt; &quot;&quot;</span>
<span class="gp">&gt;&gt; </span><span class="s2">&quot;foo&quot;</span>      <span class="c1"># Une chaine non vide</span>
<span class="go">=&gt; &quot;foo&quot;</span>
</pre></div>
</div>


<p>Voici des <em>chaines littérales</em>, créées en utilisant les guillemets double &nbsp;<code>"</code>. La console écrit le résultat de l'évaluation de chaque ligne, qui dans le cas d'une chaine littérale est juste la chaine elle-même.</p>

<p>Nous pouvons aussi <em>concaténer</em> des chaines avec l'opérateur <code>+</code>&nbsp;:</p>

<div class="code"><div class="highlight"><pre><span class="gp">&gt;&gt; </span><span class="s2">&quot;foo&quot;</span> <span class="o">+</span> <span class="s2">&quot;bar&quot;</span>    <span class="c1"># Concaténation de chaines</span>
<span class="go">=&gt; &quot;foobar&quot;</span>
</pre></div>
</div>


<p>Ici, l'évaluation de <code>"foo"</code> <em>plus</em> <code>"bar"</code> donne la chaine <code>"foobar"</code>.<sup class="footnote" id="fnref:4.6"><a href="#fn:4.6">6</a></sup></p>

<p>Une autre façon de contruire des chaines de caractère se fait via l'<em>interpolation</em> en utilisant la syntaxe spéciale <code>#{}</code>&nbsp;:<sup class="footnote" id="fnref:4.7"><a href="#fn:4.7">7</a></sup></p>

<div class="code"><div class="highlight"><pre><span class="gp">&gt;&gt; </span><span class="n">first_name</span> <span class="o">=</span> <span class="s2">&quot;Michael&quot;</span>    <span class="c1"># Déclaration de variable</span>
<span class="go">=&gt; &quot;Michael&quot;</span>
<span class="gp">&gt;&gt; </span><span class="s2">&quot;</span><span class="si">#{</span><span class="n">first_name</span><span class="si">}</span><span class="s2"> Hartl&quot;</span>     <span class="c1"># Interpolation de chaine</span>
<span class="go">=&gt; &quot;Michael Hartl&quot;</span>
</pre></div>
</div>


<p>Ici, nous avons <em>assigné</em> la valeur <code>"Michael"</code> à la variable <code>first_name</code> et l'avons <em>interpolée</em> à l'intérieur de la chaine <code>"#{first_name} Hartl"</code>. Nous pouvons aussi assigner les deux chaines à une variable&nbsp;:</p>

<div class="code"><div class="highlight"><pre><span class="gp">&gt;&gt; </span><span class="n">first_name</span> <span class="o">=</span> <span class="s2">&quot;Michael&quot;</span>
<span class="go">=&gt; &quot;Michael&quot;</span>
<span class="gp">&gt;&gt; </span><span class="n">last_name</span> <span class="o">=</span> <span class="s2">&quot;Hartl&quot;</span>
<span class="go">=&gt; &quot;Hartl&quot;</span>
<span class="gp">&gt;&gt; </span><span class="n">first_name</span> <span class="o">+</span> <span class="s2">&quot; &quot;</span> <span class="o">+</span> <span class="n">last_name</span>    <span class="c1"># Concaténation, avec une espace <!-- féminin en typo ! -->entre les deux</span>
<span class="go">=&gt; &quot;Michael Hartl&quot;</span>
<span class="gp">&gt;&gt; </span><span class="s2">&quot;</span><span class="si">#{</span><span class="n">first_name</span><span class="si">}</span><span class="s2"> </span><span class="si">#{</span><span class="n">last_name</span><span class="si">}</span><span class="s2">&quot;</span>    <span class="c1"># L'interpolation équivalente</span>
<span class="go">=&gt; &quot;Michael Hartl&quot;</span>
</pre></div>
</div>


<p>Notez que les deux expressions finales sont équivalentes, mais je préfère la version interpolée&nbsp;; avoir à ajouter une simple espace<!-- féminin en typo --> <code>"&nbsp;"</code> semble un peu maladroit.</p>

<div class="label" id="sec:printing"></div>


<h4><a id="sec:4.2.2.1" href="rails-flavored-ruby#sec:printing" class="heading">Impression</a></h4>


<p>Pour <em>imprimer</em> une chaine de caractère, la fonction Ruby utilisée le plus couramment est <code>puts</code> (pronconcez &ldquo;put ess&rdquo; en anglais, pour &ldquo;put string&rdquo;)&nbsp;:</p>

<div class="code"><div class="highlight"><pre><span class="gp">&gt;&gt; </span><span class="nb">puts</span> <span class="s2">&quot;foo&quot;</span>     <span class="c1"># put string</span>
<span class="go">foo</span>
<span class="go">=&gt; nil</span>
</pre></div>
</div>


<p>La méthode <code>puts</code> opère comme un <em>effet secondaire</em>&nbsp;: l'expression <code>puts "foo"</code> affiche la chaine à l'écran et ne retourne ensuite <a href="http://www.answers.com/nil">litéralement rien du tout</a>&nbsp;: <code>nil</code> (<em>nul</em>) est une valeur Ruby spéciale pour &ldquo;<a href="http://www.youtube.com/watch?v=AsZ9qFofOwo">rien du tout</a>&rdquo; (par la suite, je supprimerai parfois la partie <code>=&gt; nil</code> pour simplifier).</p>

<p>L'utilisation de <code>puts</code> ajoute automatiquement un caractère de nouvelle ligne&nbsp;<tt class="verb">\n</tt> à la sortie&nbsp;; la méthode <code>print</code> liée ne le fait pas&nbsp;:</p>

<div class="code"><div class="highlight"><pre><span class="gp">&gt;&gt; </span><span class="nb">print</span> <span class="s2">&quot;foo&quot;</span>    <span class="c1"># imprime la chaine (même chose que puts, mais sans nouvelle ligne)</span>
<span class="go">foo=&gt; nil</span>
<span class="gp">&gt;&gt; </span><span class="nb">print</span> <span class="s2">&quot;foo</span><span class="se">\n</span><span class="s2">&quot;</span>  <span class="c1"># Même chose que puts &quot;foo&quot;</span>
<span class="go">foo</span>
<span class="go">=&gt; nil</span>
</pre></div>
</div>




<div class="label" id="sec:single_quoted_strings"></div>


<h4><a id="sec:4.2.2.2" href="rails-flavored-ruby#sec:single_quoted_strings" class="heading">Chaines de caractères avec apostrophe simple</a></h4>


<p>Tous les exemples précédents utilisaient les <em>chaines entre guillemets</em>, mais Ruby supporte aussi les <em>chaines apostrophes simples</em>. Pour de nombreux usages, les deux types de chaines sont en fait identiques&nbsp;:</p>

<div class="code"><div class="highlight"><pre><span class="gp">&gt;&gt; </span><span class="s1">&#39;foo&#39;</span>          <span class="c1"># Une chaine apostrophe simple</span>
<span class="go">=&gt; &quot;foo&quot;</span>
<span class="gp">&gt;&gt; </span><span class="s1">&#39;foo&#39;</span> <span class="o">+</span> <span class="s1">&#39;bar&#39;</span>
<span class="go">=&gt; &quot;foobar&quot;</span>
</pre></div>
</div>


<p>Il existe cependant une différence de taille&nbsp;; Ruby ne procède à aucune interpolation à l'intérieur d'une chaine apostrophe simple&nbsp;:</p>

<div class="code"><div class="highlight"><pre><span class="gp">&gt;&gt; </span><span class="s1">&#39;#{foo} bar&#39;</span>     <span class="c1"># Les chaines apostrophe simple ne permettent pas l'interpolation</span>
<span class="go">=&gt; &quot;\#{foo} bar&quot;</span>
</pre></div>
</div>


<p>Notez comment la console retourne des valeurs en utilisant des chaines entre guillemets, ce qui demande d'utiliser le caractère spécial d'échappement (<em>backslash</em>) tel que&nbsp;<code>#</code>.</p>

<p>Si les chaines entre guillemets peuvent faire tout ce que font les chaines entre apostrophes, et peuvent interpoler, quelle est l'utilité des chaines apostrophiées&nbsp;? Elles sont souvent utiles parce qu'elles sont vraiment <em>litérales</em>, et contiennent réellement les caractères que vous tapez. Par exemple, le caractère d'échappement &ldquo;&nbsp;backslash&nbsp;&rdquo; est un caractère spécial sur la plupart des systèmes, comme dans le retour à la ligne&nbsp;<tt class="verb">\n</tt>. Si vous voulez qu'une variable contienne un caractère d'échappement littéral, les apostrophes seront plus pratiques&nbsp;:</p>

<div class="code"><div class="highlight"><pre><span class="gp">&gt;&gt; </span><span class="s1">&#39;\n&#39;</span>       <span class="c1"># Une combinaison à échappement littéral</span>
<span class="go">=&gt; &quot;\\n&quot;</span>
</pre></div>
</div>


<p>Comme avec le caractère&nbsp;<code>#</code> de notre exemple précédent, Ruby a besoin d'échapper le caractère d'échappement lui-même&nbsp;; à l'intérieur d'une chaine entre guillemets, un échappement littéral doit être représenté par <em>deux</em> échappements. Pour un court exemple comme celui-là, il n'y a pas un gain énorme, mais s'il y a beaucoup de choses à échapper ça peut être d'une grand utilité&nbsp;:</p>

<div class="code"><div class="highlight"><pre><span class="gp">&gt;&gt; </span><span class="s1">&#39;Les nouvelles lignes (\n) et les tabulations (\t) utilisent toutes</span>
<span class="s1">&nbsp;&nbsp;&nbsp;deux les échappements \.&#39;</span>
<span class="go">=&gt; &quot;Les nouvelles lignes (\\n) et les tabulations (\\t) utilisent toutes</span>
<span class="go">deux les échappements \\.&quot;</span>
</pre></div>
</div>




<div class="label" id="sec:objects_and_message_passing"></div>


<h3><a id="sec:4.2.3" href="rails-flavored-ruby#sec:objects_and_message_passing" class="heading"><span class="number">4.2.3</span> Objets et passage de message</a></h3>


<p>Tout, en Ruby, les chaines et même la valeur <code>nil</code> (<em>nul</em>), sont des <em>objets</em>. Nous verrons le sens technique de cela à la <a class="ref" href="rails-flavored-ruby#sec:a_class_of_our_own">section&nbsp;4.4.2</a>, et je pense que personne n'a jamais compris ce qu'était un <em>objet</em> en en lisant la définition dans un livre&nbsp;; vous devez vous faire une idée intuitive des objets en consultant un grand nombre d'exemples.</p>

<p>Il est beaucoup plus facile de décrire ce que les objets <em>font</em>, qui est de répondre aux messages. Un objet comme une chaine de caractères, par exemple, peut répondre au message <code>length</code> (<em>longueur</em>), qui retourne le nombre de signes/caractères de la chaine&nbsp;:</p>

<div class="code"><div class="highlight"><pre><span class="gp">&gt;&gt; </span><span class="s2">&quot;foobar&quot;</span><span class="o">.</span><span class="n">length</span>        <span class="c1"># Passer le message &quot;length&quot; à la chaine</span>
<span class="go">=&gt; 6</span>
</pre></div>
</div>


<p>Typiquement, les messages qui peuvent être passés aux objets sont appelés des <em>méthodes</em>, qui sont des fonctions définis pour ces objets.<sup class="footnote" id="fnref:4.8"><a href="#fn:4.8">8</a></sup> Les chaines répondent aussi à la méthode <code>empty?</code> (<em>vide&nbsp;?</em>)&nbsp;:</p>

<div class="code"><div class="highlight"><pre><span class="gp">&gt;&gt; </span><span class="s2">&quot;foobar&quot;</span><span class="o">.</span><span class="n">empty?</span>
<span class="go">=&gt; false</span>        <span class="c1"># = Faux</span>
<span class="gp">&gt;&gt; </span><span class="s2">&quot;&quot;</span><span class="o">.</span><span class="n">empty?</span>
<span class="go">=&gt; true</span>        <span class="c1"># = Vrai</span>
</pre></div>
</div>


<p>Notez le point d'interrogation à la fin de la méthode <code>empty?</code>. C'est une convention Ruby indiquant que la valeur de retour est <em>booléenne</em>&nbsp;: <code>true</code> (<em>vrai</em>) ou <code>false</code> (<em>faux</em>). Les booléens sont particulièrement utiles pour le <em>contrôle de flux</em>&nbsp;:</p>

<div class="code"><div class="highlight"><pre><span class="gp">&gt;&gt; </span><span class="n">s</span> <span class="o">=</span> <span class="s2">&quot;foobar&quot;</span>
<span class="gp">&gt;&gt; </span><span class="k">if</span> <span class="n">s</span><span class="o">.</span><span class="n">empty?</span>
<span class="gp">&gt;&gt; </span>  <span class="s2">&quot;La chaine est vide&quot;</span>
<span class="gp">&gt;&gt; </span><span class="k">else</span>
<span class="gp">&gt;&gt; </span>  <span class="s2">&quot;La chaine n'est pas vide&quot;</span>
<span class="gp">&gt;&gt; </span><span class="k">end</span>
<span class="go">=&gt; &quot;La chaine n'est pas vide&quot;</span>
</pre></div>
</div>


<p>Les booléens peuvent aussi être combinés en utilisant les opérateurs <code>&amp;&amp;</code> (&ldquo;&nbsp;et&nbsp;&rdquo;), <code>||</code> (&ldquo;&nbsp;ou&nbsp;&rdquo;) et <code>!</code> (&ldquo;&nbsp;pas&nbsp;&rdquo;)&nbsp;:</p>

<div class="code"><div class="highlight"><pre><span class="gp">&gt;&gt; </span><span class="n">x</span> <span class="o">=</span> <span class="s2">&quot;foo&quot;</span>
<span class="go">=&gt; &quot;foo&quot;</span>
<span class="gp">&gt;&gt; </span><span class="n">y</span> <span class="o">=</span> <span class="s2">&quot;&quot;</span>
<span class="go">=&gt; &quot;&quot;</span>
<span class="gp">&gt;&gt; </span><span class="nb">puts</span> <span class="s2">&quot;Les deux chaines sont vides&quot;</span> <span class="k">if</span> <span class="n">x</span><span class="o">.</span><span class="n">empty?</span> <span class="o">&amp;&amp;</span> <span class="n">y</span><span class="o">.</span><span class="n">empty?</span>
<span class="go">=&gt; nil</span>
<span class="gp">&gt;&gt; </span><span class="nb">puts</span> <span class="s2">&quot;L'une des chaines est vide&quot;</span> <span class="k">if</span> <span class="n">x</span><span class="o">.</span><span class="n">empty?</span> <span class="o">||</span> <span class="n">y</span><span class="o">.</span><span class="n">empty?</span>
<span class="go">&quot;L'une des chaines est vide&quot;</span>
<span class="go">=&gt; nil</span>
<span class="gp">&gt;&gt; </span><span class="nb">puts</span> <span class="s2">&quot;x n'est pas vide&quot;</span> <span class="k">if</span> <span class="o">!</span><span class="n">x</span><span class="o">.</span><span class="n">empty?</span>
<span class="go">&quot;x n'est pas vide&quot;</span>
</pre></div>
</div>


<p>Puisque tout en Ruby est objet, il en découle que <code>nil</code> (la valeur <em>nul</em>) est un objet, donc elle peut répondre aussi aux méthodes.  Un exemple est la méthode <code>to_s</code> qui peut virtuellement convertir tout objet en chaine de caractère&nbsp;:</p>

<div class="code"><div class="highlight"><pre><span class="gp">&gt;&gt; </span><span class="kp">nil</span><span class="o">.</span><span class="n">to_s</span>
<span class="go">=&gt; &quot;&quot;</span>
</pre></div>
</div>


<p>Cela apparait certainement comme une chaine vide, comme nous pouvons le vérifier en <em>chainant</em> les messages que où nous passons <code>nil</code>:</p>

<div class="code"><div class="highlight"><pre><span class="gp">&gt;&gt; </span><span class="kp">nil</span><span class="o">.</span><span class="n">empty?</span>
<span class="go">NoMethodError: You have a nil object when you didn&#39;t expect it!</span>
<span class="go">You might have expected an instance of Array.</span>
<span class="go">The error occurred while evaluating nil.empty?</span>
<span class="go"><span class="c1">(</span></span>
<span class="go"><span class="c1">Traduction du message d'erreur&nbsp;:</span></span>
<span class="go"><span class="c1">ErreurDAbsenceDeMethode: Vous avez un objet null inattendu&nbsp;!</span></span>
<span class="go"><span class="c1">Vous attendiez peut-être une instance de tableau (Array)</span></span>
<span class="go"><span class="c1">L'erreur est survenue en évaluant l'expression nil.empty?</span></span>
<span class="go"><span class="c1">)</span></span>
<span class="gp">&gt;&gt; </span><span class="kp">nil</span><span class="o">.</span><span class="n">to_s</span><span class="o">.</span><span class="n">empty?</span>      <span class="c1"># Chainage du message</span>
<span class="go">=&gt; true</span>
</pre></div>
</div>


<p>Nous voyons ici que l'objet <code>nil</code> ne répond pas de lui-même à la méthode <code>empty?</code>, mais <code>nil.to_s</code> le fait.</p>

<p>Il existe une méthode spéciale pour tester la <code>nullité</code>, que vous devriez être en mesure de deviner&nbsp;:</p>

<div class="code"><div class="highlight"><pre><span class="gp">&gt;&gt; </span><span class="s2">&quot;foo&quot;</span><span class="o">.</span><span class="n">nil?</span>
<span class="go">=&gt; false</span>
<span class="gp">&gt;&gt; </span><span class="s2">&quot;&quot;</span><span class="o">.</span><span class="n">nil?</span>
<span class="go">=&gt; false</span>
<span class="gp">&gt;&gt; </span><span class="kp">nil</span><span class="o">.</span><span class="n">nil?</span>
<span class="go">=&gt; true</span>
</pre></div>
</div>


<p>Si vous retournez à l'<a class="ref" href="rails-flavored-ruby#code:title_helper">extrait&nbsp;4.2</a>, vous verrez que l'<em>helper</em> de titre (<code>title</code>) teste pour voir si la variable <code>@title</code> est <code>nil</code> en utilisant la méthode <code>nil?</code>. C'est le signe qu'il y a quelque chose de spécial à propos des variables d'instance (les variables commençant par un signe &nbsp;<code>@</code>), qui peut être mieux compris en les comparant aux variables ordinaires. Par exemple, supposons que nous entrions les deux variables <code>title</code> et <code>@title</code> à la console sans les définir avant&nbsp;:</p>

<div class="code"><div class="highlight"><pre><span class="gp">&gt;&gt; </span><span class="n">titre</span>        <span class="c1"># Houps ! Nous n'avons pas défini la variable titre.</span>
<span class="go">NameError: undefined local variable or method `titre&#39; </span>
<span class="gp">&gt;&gt; </span><span class="vi">@titre</span>       <span class="c1"># Une variable d'instance dans la console</span>
<span class="go">=&gt; nil</span>
<span class="gp">&gt;&gt; </span><span class="nb">puts</span> <span class="s2">&quot;Il n'y a pas de telle variable d'instance.&quot;</span> <span class="k">if</span> <span class="vi">@titre</span><span class="o">.</span><span class="n">nil?</span>
<span class="go">Il n'y a pas de telle variable d'instance.</span>
<span class="go">=&gt; nil</span>
<span class="gp">&gt;&gt; </span><span class="s2">&quot;</span><span class="si">#{</span><span class="vi">@titre</span><span class="si">}</span><span class="s2">&quot;</span>  <span class="c1"># Interpolationne @titre quand elle est nulle</span>
<span class="go">=&gt; &quot;&quot;</span>
</pre></div>
</div>


<p>Vous pouvez voir dans cet exemple que Ruby se plaint si nous essayons d'évaluer une variable locale, mais ne renvoie pas cette plainte pour une variable d'instance qui n'existe pas&nbsp;; à la place, les variables d'instance sont <code>nil</code> si elles ne sont pas définies. Cela explique pourquoi le code…</p>

<div class="code"><div class="highlight"><pre>Simple App du Tutoriel Ruby on Rails | <span class="cp">&lt;%=</span> <span class="vi">@title</span> <span class="cp">%&gt;</span>
</pre></div>
</div>


<p>… devient…</p>

<div class="code"><div class="highlight"><pre>Simple App du Tutoriel Ruby on Rails | 
</pre></div>
</div>


<p>… quand <code>@title</code> est <code>nil</code>: Le Ruby embarqué insère la chaine correspondant à la variable donnée, est la chaine correspondant à la valeur <code>nil</code> est une chaine vide&nbsp;<code>""</code>.</p>

<p>Le dernier exemple montre aussi un usage alternatif du mot-clé <code>if</code>&nbsp;: Ruby vous permet d'écrire des blocs qui ne sont évalués que si l'expression suivant le <code>if</code> est vraie. Il existe un mot-clé complémentaire, <code>unless</code>, qui fonctionne de la même façon&nbsp;:</p>

<div class="code"><div class="highlight"><pre><span class="gp">&gt;&gt; </span><span class="n">string</span> <span class="o">=</span> <span class="s2">&quot;foobar&quot;</span>
<span class="gp">&gt;&gt; </span><span class="nb">puts</span> <span class="s2">&quot;La chaine &#39;</span><span class="si">#{</span><span class="n">string</span><span class="si">}</span><span class="s2">&#39; n'est pas vide.&quot;</span> <span class="k">unless</span> <span class="n">string</span><span class="o">.</span><span class="n">empty?</span>
<span class="go">La chaine string &#39;foobar&#39; n'est pas vide.</span>
<span class="go">=&gt; nil</span>
</pre></div>
</div>


<p>Il est important de noter que l'objet <code>nil</code> est spécial, dans le sens où c'est le <em>seule</em> objet Ruby object qui est <em>faux</em> dans un contexte booléen, à part bien sûr le <code>false</code> lui-même&nbsp;:</p>

<div class="code"><div class="highlight"><pre><span class="gp">&gt;&gt; </span><span class="k">if</span> <span class="kp">nil</span>
<span class="gp">&gt;&gt; </span>  <span class="kp">true</span>
<span class="gp">&gt;&gt; </span><span class="k">else</span>
<span class="gp">&gt;&gt; </span>  <span class="kp">false</span>        <span class="c1"># nil is false</span>
<span class="gp">&gt;&gt; </span><span class="k">end</span>
<span class="go">=&gt; false</span>
</pre></div>
</div>

<p>En particulier, tous les autres objets Ruby sont <em>true</em>, même 0&nbsp;:</p>

<div class="code"><div class="highlight"><pre><span class="gp">&gt;&gt; </span><span class="k">if</span> <span class="mi">0</span>
<span class="gp">&gt;&gt; </span>  <span class="kp">true</span>        <span class="c1"># 0 (et toute autre valeur que nil et false) est vrai</span>
<span class="gp">&gt;&gt; </span><span class="k">else</span>
<span class="gp">&gt;&gt; </span>  <span class="kp">false</span>
<span class="gp">&gt;&gt; </span><span class="k">end</span>
<span class="go">=&gt; true</span>
</pre></div>
</div>


<div class="label" id="sec:method_definitions"></div>


<h3><a id="sec:4.2.4" href="rails-flavored-ruby#sec:method_definitions" class="heading"><span class="number">4.2.4</span> Définition des méthodes</a></h3>


<p>La console nous permet de définir des méthodes de la même façon que nous le faisions avec l'action <code>home</code> de l'<a class="ref" href="static-pages#code:pages_controller">extrait&nbsp;3.6</a> ou l'<em>helper</em> de <code>title</code> de l'<a class="ref" href="rails-flavored-ruby#code:title_helper">extrait&nbsp;4.2</a> (définir des méthodes dans la console est un peu lourd, et d'ordinaire on utilise plutôt un fichier, mais c'est pratique ici pour les besoins de la démonstration). Par exemple, définissons une fonction <code>string_message</code> qui prend un seul <em>argument</em> et retourne un message en fonction de la nullité ou non de l'argument&nbsp;:</p>

<div class="code"><div class="highlight"><pre><span class="gp">&gt;&gt; </span><span class="k">def</span> <span class="nf">string_message</span><span class="p">(</span><span class="n">string</span><span class="p">)</span>
<span class="gp">&gt;&gt; </span>  <span class="k">if</span> <span class="n">string</span><span class="o">.</span><span class="n">empty?</span>
<span class="gp">&gt;&gt; </span>    <span class="s2">&quot;C'est une chaine vide&nbsp;!&quot;</span>
<span class="gp">&gt;&gt; </span>  <span class="k">else</span>
<span class="gp">&gt;&gt; </span>    <span class="s2">&quot;La chaine n'est pas vide.&quot;</span>
<span class="gp">&gt;&gt; </span>  <span class="k">end</span>
<span class="gp">&gt;&gt; </span><span class="k">end</span>
<span class="go">=&gt; nil</span>
<span class="gp">&gt;&gt; </span><span class="nb">puts</span> <span class="n">string_message</span><span class="p">(</span><span class="s2">&quot;&quot;</span><span class="p">)</span>
<span class="go">C'est une chaine vide&nbsp;!</span>
<span class="gp">&gt;&gt; </span><span class="nb">puts</span> <span class="n">string_message</span><span class="p">(</span><span class="s2">&quot;foobar&quot;</span><span class="p">)</span>
<span class="go">La chaine n'est pas vide.</span>
</pre></div>
</div>


<p>Notez que les fonctions Ruby ont un <em>retour implicite</em>, ce qui signifie qu'elles retournent la valeur de la dernière expression évaluée &mdash;&nbsp;dans ce cas, l'un des deux messages, en fonction du fait que l'argument <code>string</code> de la fonction est vide ou non. Ruby possède aussi une option de définir de retour explicite&nbsp;; la fonction suivante est équivalente à celle ci-dessus&nbsp;:</p>

<div class="code"><div class="highlight"><pre><span class="gp">&gt;&gt; </span><span class="k">def</span> <span class="nf">string_message</span><span class="p">(</span><span class="n">string</span><span class="p">)</span>
<span class="gp">&gt;&gt; </span>  <span class="k">return</span> <span class="s2">&quot;C'est une chaine vide&nbsp;!&quot;</span> <span class="k">if</span> <span class="n">string</span><span class="o">.</span><span class="n">empty?</span>
<span class="gp">&gt;&gt; </span>  <span class="k">return</span> <span class="s2">&quot;La chaine n'est pas vide.&quot;</span>
<span class="gp">&gt;&gt; </span><span class="k">end</span>
</pre></div>
</div>


<p>Le lecteur attentif pourra noter à ce point que le second <code>return</code> ici est en fait superfétatoire &mdash;&nbsp;étant la dernière expression de la fonction, la chaine <code>"La chaine n'est pas vide."</code> sera retourné sans égard pour le mot-clé <code>return</code>, mais utiliser <code>return</code> aux deux endroits présente une symétrie plaisante.</p>

<div class="label" id="sec:back_to_the_title_helper"></div>


<h3><a id="sec:4.2.5" href="rails-flavored-ruby#sec:back_to_the_title_helper" class="heading"><span class="number">4.2.5</span> De retour à l'<em>helper</em> <code>title</code></a></h3>


<p>Nous sommes maintenant en mesure de comprendre l'<em>helper</em> <code>title</code> helper de l'<a class="ref" href="rails-flavored-ruby#code:title_helper">extrait&nbsp;4.2</a>&nbsp;:<sup class="footnote" id="fnref:4.9"><a href="#fn:4.9">9</a></sup></p>

<div class="code"><div class="highlight"><pre><span class="k">module</span> <span class="nn">ApplicationHelper</span>

  <span class="c1"># Retourne un titre propre à la page.               # Commentaire de documentation</span>
  <span class="k">def</span> <span class="nf">title</span>                                           <span class="c1"># Définition de la méthode</span>
    <span class="n">base_title</span> <span class="o">=</span> <span class="s2">&quot;Simple App du Tutoriel Ruby on Rails&quot;</span>  <span class="c1"># Assignement de variable</span>
    <span class="k">if</span> <span class="vi">@title</span><span class="o">.</span><span class="n">nil?</span>                                    <span class="c1"># Test booléen pour la nullité</span>
      <span class="n">base_title</span>                                      <span class="c1"># Retour implicite</span>
    <span class="k">else</span>
      <span class="s2">&quot;</span><span class="si">#{</span><span class="n">base_title</span><span class="si">}</span><span class="s2"> | </span><span class="si">#{</span><span class="vi">@title</span><span class="si">}</span><span class="s2">&quot;</span>                     <span class="c1"># Interpolation de chaine</span>
    <span class="k">end</span>
  <span class="k">end</span>
<span class="k">end</span>
</pre></div>
</div>


<p>Ces éléments &mdash;&nbsp;fonction, définition, assignement de variable, tests booléens, contrôle de flux et extrapolation de chaine&nbsp;&mdash; se combinent pour créer une méthode d'helper compacte à utiliser dans notre <em>layout</em>. L'élément final est <code>module ApplicationHelper</code>&nbsp;: le code dans les modules Ruby peut être <em>divisé</em> en classes Ruby. En écrivant du Ruby ordinaire, vous écrivez souvent des modules et les incluez explicitement vous-mêmes, mais dans notre cas Rails gère l'inclusion automatiquement pour nous. Le résultat est que la méthode <code>title</code> est <a href="http://catb.org/jargon/html/A/automagically.html"><em>automagiquement</em></a>&nbsp;(sic) accessible à toutes nos vues.</p>

<div class="label" id="sec:other_data_structures"></div>


<h2><a id="sec:4.3" href="rails-flavored-ruby#sec:other_data_structures" class="heading"><span class="number">4.3</span> Autre structures de données</a></h2>


<p>Bien que les applications web produisent au final des chaines de caractères, en fait <em>fabriquer</em> ces chaines requiert d'utiliser tout autant d'autres structure de données. Dans cette section, nous allons étudier quelques structure de données Ruby importante pour la conception d'applications Rails.</p>

<div class="label" id="sec:arrays_and_ranges"></div>


<h3><a id="sec:4.3.1" href="rails-flavored-ruby#sec:arrays_and_ranges" class="heading"><span class="number">4.3.1</span> Tableaux (Arrays) et rangs (ranges)</a></h3>


<p>Un tableau (<em>array</em>) est juste une liste d'éléments dans un ordre particulier. Nous n'avons pas encore abordé les tableaux dans ce <em>Tutoriel Rails</em>, mais les comprendre offre de bons fondements pour comprendre les table de hachage (<em>hashes</em>) (<a class="ref" href="rails-flavored-ruby#sec:hashes_and_symbols">section&nbsp;4.3.3</a>) et les aspects de la modélisation des données de Rails (tels que l'association <code>has_many</code> vue à la <a class="ref" href="a-demo-app#sec:demo_user_has_many_microposts">section&nbsp;2.3.3</a> et couverte plus largement à la <a class="ref" href="user-microposts#sec:user_micropost_associations">section&nbsp;11.1.2</a>).</p>

<p>Jusqu'ici nous avons passé beaucoup de temps à comprendre les chaines de caractères, et il existe un façon naturelle de passer des chaines aux tableaux en utilisant la méthode <code>split</code> (<em>scinder</em>)&nbsp;:</p>

<div class="code"><div class="highlight"><pre><span class="gp">&gt;&gt; </span> <span class="s2">&quot;foo bar     baz&quot;</span><span class="o">.</span><span class="n">split</span>     <span class="c1"># Scinde une chaine en trois éléments</span>
<span class="go">=&gt; [&quot;foo&quot;, &quot;bar&quot;, &quot;baz&quot;]</span>
</pre></div>
</div>


<p>Le résultat de cette opération est un tableau de trois chaines. Par défaut,  <code>split</code> divise une chaine en tableau en la scindant selon les <em>espaces blancs</em> (<em>whitespace</em>), mais vous pouvez scinder tout aussi bien scinder selon n'importe quelle autre chose&nbsp;:</p>

<div class="code"><div class="highlight"><pre><span class="gp">&gt;&gt; </span><span class="s2">&quot;fooxbarxbazx&quot;</span><span class="o">.</span><span class="n">split</span><span class="p">(</span><span class="s1">&#39;x&#39;</span><span class="p">)</span>
<span class="go">=&gt; [&quot;foo&quot;, &quot;bar&quot;, &quot;baz&quot;]</span>
</pre></div>
</div>


<p>Comme cela est conventionnel pour de nombreux langague informatique, les tableaux Ruby sont <em>zero-offset</em> (<em>décalage-zéro</em>), ce qui signifie que le premier élément dans la liste possède l'index&nbsp;0, le deuxième l'index&nbsp;1, et ainsi de suite&nbsp;:</p>

<div class="code"><div class="highlight"><pre><span class="gp">&gt;&gt; </span><span class="n">a</span> <span class="o">=</span> <span class="o">[</span><span class="mi">42</span><span class="p">,</span> <span class="mi">8</span><span class="p">,</span> <span class="mi">17</span><span class="o">]</span>
<span class="go">=&gt; [42, 8, 17]</span>
<span class="gp">&gt;&gt; </span><span class="n">a</span><span class="o">[</span><span class="mi">0</span><span class="o">]</span>               <span class="c1"># Ruby utilise les crochets pour l'accès aux éléments.</span>
<span class="go">=&gt; 42</span>
<span class="gp">&gt;&gt; </span><span class="n">a</span><span class="o">[</span><span class="mi">1</span><span class="o">]</span>
<span class="go">=&gt; 8</span>
<span class="gp">&gt;&gt; </span><span class="n">a</span><span class="o">[</span><span class="mi">2</span><span class="o">]</span>
<span class="go">=&gt; 17</span>
<span class="gp">&gt;&gt; </span><span class="n">a</span><span class="o">[-</span><span class="mi">1</span><span class="o">]</span>              <span class="c1"># Les indices peuvent même être négatifs&nbsp;!</span>
<span class="go">=&gt; 17</span>
</pre></div>
</div>


<p>Nous voyons ici que Ruby utilise des crochets pour accéder aux éléments du tableau. En addition à cette notation par crochets, Ruby offre des synonymes pour l'accès à certains éléments courants&nbsp;:<sup class="footnote" id="fnref:4.10"><a href="#fn:4.10">10</a></sup></p>

<div class="code"><div class="highlight"><pre><span class="gp">&gt;&gt; </span><span class="n">a</span>                  <span class="c1"># Pour se rappeler ce qu'est &#39;a&#39; </span>
<span class="go">=&gt; [42, 8, 17]</span>
<span class="gp">&gt;&gt; </span><span class="n">a</span><span class="o">.</span><span class="n">first</span>
<span class="go">=&gt; 42</span>
<span class="gp">&gt;&gt; </span><span class="n">a</span><span class="o">.</span><span class="n">second</span>
<span class="go">=&gt; 8</span>
<span class="gp">&gt;&gt; </span><span class="n">a</span><span class="o">.</span><span class="n">last</span>
<span class="go">=&gt; 17</span>
<span class="gp">&gt;&gt; </span><span class="n">a</span><span class="o">.</span><span class="n">last</span> <span class="o">==</span> <span class="n">a</span><span class="o">[-</span><span class="mi">1</span><span class="o">]</span>    <span class="c1"># Comparaison avec ==</span>
<span class="go">=&gt; true</span>
</pre></div>
</div>


<p>La dernière ligne introduit l'opérateur de comparaison d'égalité <code>==</code>, que Ruby partage avec de nombreux autres langages, tout comme les opérations liés <code>!=</code> (&ldquo;&nbsp;différent de…&nbsp;&rdquo;), etc.&nbsp;:</p>

<div class="code"><div class="highlight"><pre><span class="gp">&gt;&gt; </span><span class="n">x</span> <span class="o">=</span> <span class="n">a</span><span class="o">.</span><span class="n">length</span>       <span class="c1"># Comme les chaines, les tableaux répondent à la méthode &#39;length&#39;.</span>
<span class="go">=&gt; 3</span>
<span class="gp">&gt;&gt; </span><span class="n">x</span> <span class="o">==</span> <span class="mi">3</span>
<span class="go">=&gt; true</span>
<span class="gp">&gt;&gt; </span><span class="n">x</span> <span class="o">==</span> <span class="mi">1</span>
<span class="go">=&gt; false</span>
<span class="gp">&gt;&gt; </span><span class="n">x</span> <span class="o">!=</span> <span class="mi">1</span>
<span class="go">=&gt; true</span>
<span class="gp">&gt;&gt; </span><span class="n">x</span> <span class="o">&gt;=</span> <span class="mi">1</span>
<span class="go">=&gt; true</span>
<span class="gp">&gt;&gt; </span><span class="n">x</span> <span class="o">&lt;</span> <span class="mi">1</span>
<span class="go">=&gt; false</span>
</pre></div>
</div>


<p>En addition à <code>length</code> (aperçu dans la première ligne ci-dessus), les tableaux répondent à une foule d'autres méthodes&nbsp;:</p>

<div class="code"><div class="highlight"><pre><span class="gp">&gt;&gt; </span><span class="n">a</span><span class="o">.</span><span class="n">sort</span>
<span class="go">=&gt; [8, 17, 42]</span>
<span class="gp">&gt;&gt; </span><span class="n">a</span><span class="o">.</span><span class="n">reverse</span>
<span class="go">=&gt; [17, 8, 42]</span>
<span class="gp">&gt;&gt; </span><span class="n">a</span><span class="o">.</span><span class="n">shuffle</span>
<span class="go">=&gt; [17, 42, 8]</span>
</pre></div>
</div>


<p>Vous pouvez aussi faire des ajouts aux tableaux avec l'opérateur &ldquo;&nbsp;push&nbsp;&rdquo;, <code>&lt;&lt;</code>&nbsp;:</p>

<div class="code"><div class="highlight"><pre><span class="gp">&gt;&gt; </span><span class="n">a</span> <span class="o">&lt;&lt;</span> <span class="mi">7</span>                     <span class="c1"># Pousser 7 dans le tableau</span>
<span class="go">[42, 8, 17, 7]</span>
<span class="gp">&gt;&gt; </span><span class="n">a</span> <span class="o">&lt;&lt;</span> <span class="s2">&quot;foo&quot;</span> <span class="o">&lt;&lt;</span> <span class="s2">&quot;bar&quot;</span>        <span class="c1"># Chainer les ajouts</span>
<span class="go">[42, 8, 17, 7, &quot;foo&quot;, &quot;bar&quot;]</span>
</pre></div>
</div>


<p>Ce dernier exemple montre que vous pouvez chainer les ajouts ensemble, et aussi que, contrairement aux tableaux dans d'autres langages, les tableaux Ruby peuvent contenir des éléments de types différents (dans ce cs, des chaines de caractères et des entiers).</p>

<p>Nous avons vu précédemment que <code>split</code> convertissait une chaine de caractères en tableau. Nous pouvons également faire le chemin inverse avec la méthode <code>join</code> (<em>joindre</em>)&nbsp;:</p>

<div class="code"><div class="highlight"><pre><span class="gp">&gt;&gt; </span><span class="n">a</span>
<span class="go">=&gt; [42, 8, 17, 7, &quot;foo&quot;, &quot;bar&quot;]</span>
<span class="gp">&gt;&gt; </span><span class="n">a</span><span class="o">.</span><span class="n">join</span>                       <span class="c1"># Joindre avec rien</span>
<span class="go">=&gt; &quot;428177foobar&quot;</span>
<span class="gp">&gt;&gt; </span><span class="n">a</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="s1">&#39;, &#39;</span><span class="p">)</span>                 <span class="c1"># Joindre avec des espaces</span>
<span class="go">=&gt; &quot;42, 8, 17, 7, foo, bar&quot;</span>
</pre></div>
</div>


<p>Très proches des tableaux arrays sont les rangs (<em>ranges</em>), qui peuvent probablement être plus facilement compréhensibles en les convertissant en tableaux à l'aide de la méhode <code>to_a</code> («&nbsp;to_a&nbsp;» pour «&nbsp;to array&nbsp;», <em>vers un tableau</em>)&nbsp;:</p>

<div class="code"><div class="highlight"><pre><span class="gp">&gt;&gt; </span><span class="mi">0</span><span class="o">.</span><span class="n">.</span><span class="mi">9</span>
<span class="go">=&gt; 0..9</span>
<span class="gp">&gt;&gt; </span><span class="mi">0</span><span class="o">.</span><span class="n">.</span><span class="mi">9</span><span class="o">.</span><span class="n">to_a</span>              <span class="c1"># Oops, call to_a on 9</span>
<span class="go">ArgumentError: bad value for range</span>
<span class="c1">(NdT. ErreurArgument: mauvaise valeur pour le rang)</span>
<span class="gp">&gt;&gt; </span><span class="p">(</span><span class="mi">0</span><span class="o">.</span><span class="n">.</span><span class="mi">9</span><span class="p">)</span><span class="o">.</span><span class="n">to_a</span>            <span class="c1"># Utiliser les parenthèses pour appeler to_a sur un rang</span>
<span class="go">=&gt; [0, 1, 2, 3, 4, 5, 6, 7, 8, 9]</span>
</pre></div>
</div>


<P>Bien que <code>0..9</code> soit un rang valide, la seconde expression ci-dessus montre que nous avons besoin d'ajouter des parenthèses pour lui appliquer la méthode.</p>

<p>Les Rangs sont utiles pour tirer des éléments d'un tableau&nbsp;:</p>

<div class="code"><div class="highlight"><pre><span class="gp">&gt;&gt; </span><span class="n">a</span> <span class="o">=</span> <span class="sx">%w[foo bar baz quux]</span>         <span class="c1"># Utilisez %w pour faire un tableau de chaines.</span>
<span class="go">=&gt; [&quot;foo&quot;, &quot;bar&quot;, &quot;baz&quot;, &quot;quux&quot;]</span>
<span class="gp">&gt;&gt; </span><span class="n">a</span><span class="o">[</span><span class="mi">0</span><span class="o">.</span><span class="n">.</span><span class="mi">2</span><span class="o">]</span>
<span class="go">=&gt; [&quot;foo&quot;, &quot;bar&quot;, &quot;baz&quot;]</span>
</pre></div>
</div>


<p>Les Rangs fonctionnent aussi avec les caractères&nbsp;:</p>

<div class="code"><div class="highlight"><pre><span class="gp">&gt;&gt; </span><span class="p">(</span><span class="s1">&#39;a&#39;</span><span class="o">.</span><span class="n">.</span><span class="s1">&#39;e&#39;</span><span class="p">)</span><span class="o">.</span><span class="n">to_a</span>
<span class="go">=&gt; [&quot;a&quot;, &quot;b&quot;, &quot;c&quot;, &quot;d&quot;, &quot;e&quot;]</span>
</pre></div>
</div>


<div class="label" id="sec:blocks"></div>

<h3><a id="sec:4.3.2" href="rails-flavored-ruby#sec:blocks" class="heading"><span class="number">4.3.2</span> Blocs</a></h3>


<p>Les tableaux (<em>arrays</em>) et les rangs (<em>ranges</em>) répondent tous deux à une foule de méthodes qui acceptent des <em>blocs</em>, qui sont en même temps une des fonctionnalités les plus puissantes et de celles qui entrainent le plus de confusion&nbsp;:</p>

<div class="code"><div class="highlight"><pre><span class="gp">&gt;&gt; </span><span class="p">(</span><span class="mi">1</span><span class="o">.</span><span class="n">.</span><span class="mi">5</span><span class="p">)</span><span class="o">.</span><span class="n">each</span> <span class="p">{</span> <span class="o">|</span><span class="n">i</span><span class="o">|</span> <span class="nb">puts</span> <span class="mi">2</span> <span class="o">*</span> <span class="n">i</span> <span class="p">}</span>
<span class="go">2</span>
<span class="go">4</span>
<span class="go">6</span>
<span class="go">8</span>
<span class="go">10</span>
<span class="go">=&gt; 1..5</span>
</pre></div>
</div>


<p>Ce code appelle la méthode <code>each</code> (<em>chaque</em>)  sur le rang <code>(1..5)</code> et lui passe le bloc <code>{ |i| puts 2 * i }</code>. La barre verticale autour du nom de la variable dans&nbsp;<code>|i|</code> est la syntaxe Ruby pour une variable de bloc, et c'est à la méthode de savoir ce qu'elle doit faire avec le bloc&nbsp;, dans ce cas précis, la méthode <code>each</code> du rang peut traiter le bloc avec une simple variable locale, que nous avons appelée&nbsp;<code>i</code>, et elle exécute simplement le block pour chaque valeur de ce rang.</p>

<p>Les accolades sont une façon d'indiquer un bloc, mais il existe une seconde façon&nbsp;:</p>

<div class="code"><div class="highlight"><pre><span class="gp">&gt;&gt; </span><span class="p">(</span><span class="mi">1</span><span class="o">.</span><span class="n">.</span><span class="mi">5</span><span class="p">)</span><span class="o">.</span><span class="n">each</span> <span class="k">do</span> <span class="o">|</span><span class="n">i</span><span class="o">|</span>
<span class="gp">?&gt; </span>  <span class="nb">puts</span> <span class="mi">2</span> <span class="o">*</span> <span class="n">i</span>
<span class="gp">&gt;&gt; </span><span class="k">end</span>
<span class="go">2</span>
<span class="go">4</span>
<span class="go">6</span>
<span class="go">8</span>
<span class="go">10</span>
<span class="go">=&gt; 1..5</span>
</pre></div>
</div>


<p>Les blocs peuvent comprendre plus d'une ligne, et en comprennent souvent plus d'une. Dans le <em>Tutoriel Rails</em> nous suivrons la convention courante d'utiliser les accolades seulement pour les blocs d'une courte ligne et la syntaxe <code>do..end</code> pour les blocs à ligne longue ou à plusieurs lignes&nbsp;:</p>

<div class="code"><div class="highlight"><pre><span class="gp">&gt;&gt; </span><span class="p">(</span><span class="mi">1</span><span class="o">.</span><span class="n">.</span><span class="mi">5</span><span class="p">)</span><span class="o">.</span><span class="n">each</span> <span class="k">do</span> <span class="o">|</span><span class="n">number</span><span class="o">|</span>
<span class="gp">?&gt; </span>  <span class="nb">puts</span> <span class="mi">2</span> <span class="o">*</span> <span class="n">number</span>
<span class="gp">&gt;&gt; </span>  <span class="nb">puts</span> <span class="s1">&#39;--&#39;</span>
<span class="gp">&gt;&gt; </span><span class="k">end</span>
<span class="go">2</span>
<span class="go">--</span>
<span class="go">4</span>
<span class="go">--</span>
<span class="go">6</span>
<span class="go">--</span>
<span class="go">8</span>
<span class="go">--</span>
<span class="go">10</span>
<span class="go">--</span>
<span class="go">=&gt; 1..5</span>
</pre></div>
</div>


<p>Ici j'ai utilisé <code>number</code> au lieu de &nbsp;<code>i</code> juste pour souligner que n'importe quel nom de variable peut convenir.</p>

<p>Sans avoir de substantielles connaissances en programmation, il n'y pas de raccourci pour comprendre les blocs&nbsp;; vous avez juste besoin d'en rencontrer beaucoup, et à la longue vous vous y ferez.<sup class="footnote" id="fnref:4.11"><a href="#fn:4.11">11</a></sup> Heureusement, les humains sont assez bons pour faire des généralisations à partir d'exemples concrets&nbsp;; en voilà d'autres, en incluant deux qui utilisent la méthode <code>map</code>&nbsp;:</p>

<div class="code"><div class="highlight"><pre><span class="gp">&gt;&gt; </span><span class="mi">3</span><span class="o">.</span><span class="n">times</span> <span class="p">{</span> <span class="nb">puts</span> <span class="s2">&quot;Betelgeuse!&quot;</span> <span class="p">}</span>   <span class="c1"># 3.fois prend un bloc sans variable.</span>
<span class="go">&quot;Betelgeuse!&quot;</span>
<span class="go">&quot;Betelgeuse!&quot;</span>
<span class="go">&quot;Betelgeuse!&quot;</span>
<span class="go">=&gt; 3</span>
<span class="gp">&gt;&gt; </span><span class="p">(</span><span class="mi">1</span><span class="o">.</span><span class="n">.</span><span class="mi">5</span><span class="p">)</span><span class="o">.</span><span class="n">map</span> <span class="p">{</span> <span class="o">|</span><span class="n">i</span><span class="o">|</span> <span class="n">i</span><span class="o">**</span><span class="mi">2</span> <span class="p">}</span>          <span class="c1"># La notation ** correspond à &#39;puissance&#39;.</span>
<span class="go">=&gt; [1, 4, 9, 16, 25]</span>
<span class="gp">&gt;&gt; </span><span class="sx">%w[a b c]</span>                        <span class="c1"># Rappel&nbsp;: fait des tableaux de chaines.</span>
<span class="go">=&gt; [&quot;a&quot;, &quot;b&quot;, &quot;c&quot;]</span>
<span class="gp">&gt;&gt; </span><span class="sx">%w[a b c]</span><span class="o">.</span><span class="n">map</span> <span class="p">{</span> <span class="o">|</span><span class="n">char</span><span class="o">|</span> <span class="n">char</span><span class="o">.</span><span class="n">upcase</span> <span class="p">}</span>
<span class="go">=&gt; [&quot;A&quot;, &quot;B&quot;, &quot;C&quot;]</span>
</pre></div>
</div>


<p>Comme vous pouvez le voir, la méthode <code>map</code> retourne le résultat après avoir appliqué le bloc donné à chaque élément d'un tableau ou d'un rang.</p>

<p>En passant, nous sommes maintenant en mesure de comprendre la ligne de Ruby que j'avais posée à la <a class="ref" href="beginning#sec:heroku_commands">section&nbsp;1.4.4</a> pour générer des sous-domaines aléatoires&nbsp;:</p>

<div class="code"><div class="highlight"><pre><span class="p">(</span><span class="s1">&#39;a&#39;</span><span class="o">.</span><span class="n">.</span><span class="s1">&#39;z&#39;</span><span class="p">)</span><span class="o">.</span><span class="n">to_a</span><span class="o">.</span><span class="n">shuffle</span><span class="o">[</span><span class="mi">0</span><span class="o">.</span><span class="n">.</span><span class="mi">7</span><span class="o">].</span><span class="n">join</span>
</pre></div>
</div>


<p>Déconstruisons-la pas à pas&nbsp;:</p>

<div class="code"><div class="highlight"><pre><span class="gp">&gt;&gt; </span><span class="p">(</span><span class="s1">&#39;a&#39;</span><span class="o">.</span><span class="n">.</span><span class="s1">&#39;z&#39;</span><span class="p">)</span><span class="o">.</span><span class="n">to_a</span>                     <span class="c1"># Un tableau de l'alphabet</span>
<span class="go">=&gt; [&quot;a&quot;, &quot;b&quot;, &quot;c&quot;, &quot;d&quot;, &quot;e&quot;, &quot;f&quot;, &quot;g&quot;, &quot;h&quot;, &quot;i&quot;, &quot;j&quot;, &quot;k&quot;, &quot;l&quot;, &quot;m&quot;, &quot;n&quot;, &quot;o&quot;,</span>
<span class="go">&quot;p&quot;, &quot;q&quot;, &quot;r&quot;, &quot;s&quot;, &quot;t&quot;, &quot;u&quot;, &quot;v&quot;, &quot;w&quot;, &quot;x&quot;, &quot;y&quot;, &quot;z&quot;]</span>
<span class="gp">&gt;&gt; </span><span class="p">(</span><span class="s1">&#39;a&#39;</span><span class="o">.</span><span class="n">.</span><span class="s1">&#39;z&#39;</span><span class="p">)</span><span class="o">.</span><span class="n">to_a</span><span class="o">.</span><span class="n">shuffle</span>             <span class="c1"># Mélangeons-le</span>
<span class="go">=&gt; [&quot;c&quot;, &quot;g&quot;, &quot;l&quot;, &quot;k&quot;, &quot;h&quot;, &quot;z&quot;, &quot;s&quot;, &quot;i&quot;, &quot;n&quot;, &quot;d&quot;, &quot;y&quot;, &quot;u&quot;, &quot;t&quot;, &quot;j&quot;, &quot;q&quot;,</span>
<span class="go">&quot;b&quot;, &quot;r&quot;, &quot;o&quot;, &quot;f&quot;, &quot;e&quot;, &quot;w&quot;, &quot;v&quot;, &quot;m&quot;, &quot;a&quot;, &quot;x&quot;, &quot;p&quot;]</span>
<span class="gp">&gt;&gt; </span><span class="p">(</span><span class="s1">&#39;a&#39;</span><span class="o">.</span><span class="n">.</span><span class="s1">&#39;z&#39;</span><span class="p">)</span><span class="o">.</span><span class="n">to_a</span><span class="o">.</span><span class="n">shuffle</span><span class="o">[</span><span class="mi">0</span><span class="o">.</span><span class="n">.</span><span class="mi">7</span><span class="o">]</span>       <span class="c1"># Tirons les huit premiers éléments.</span>
<span class="go">=&gt; [&quot;f&quot;, &quot;w&quot;, &quot;i&quot;, &quot;a&quot;, &quot;h&quot;, &quot;p&quot;, &quot;c&quot;, &quot;x&quot;]</span>
<span class="gp">&gt;&gt; </span><span class="p">(</span><span class="s1">&#39;a&#39;</span><span class="o">.</span><span class="n">.</span><span class="s1">&#39;z&#39;</span><span class="p">)</span><span class="o">.</span><span class="n">to_a</span><span class="o">.</span><span class="n">shuffle</span><span class="o">[</span><span class="mi">0</span><span class="o">.</span><span class="n">.</span><span class="mi">7</span><span class="o">].</span><span class="n">join</span>  <span class="c1"># Joignons-les pour faire une chaine de caractères.</span>
<span class="go">=&gt; &quot;mznpybuj&quot;</span>
</pre></div>
</div>




<div class="label" id="sec:hashes_and_symbols"></div>


<h3><a id="sec:4.3.3" href="rails-flavored-ruby#sec:hashes_and_symbols" class="heading"><span class="number">4.3.3</span> Tables de hachage et symboles</a></h3>


<p>Les tables de hachage (ou <em>tableaux dynamiques</em>) sont essentiellement une généralisation des tableaux-arrays&nbsp;: vous pouvez les considérer basiquement comme des tableaux, mais qui ne sont pas limités aux indices entiers (en fait, certains langages, spécialement Perl, appellent les tables de hachage des <em>tableaux associatifs</em> pour cette raison). Au lieu de ça, les indices d'une table de hachage, ou <em>keys</em>, peut être presque n'importe quel objet. Par exemple, nous pouvons utiliser des chaines de caractères comme clés&nbsp;:</p>

<div class="code"><div class="highlight"><pre><span class="gp">&gt;&gt; </span><span class="n">user</span> <span class="o">=</span> <span class="p">{}</span>                          <span class="c1"># {} est une table de hachage vide.</span>
<span class="go">=&gt; {}</span>
<span class="gp">&gt;&gt; </span><span class="n">user</span><span class="o">[</span><span class="s2">&quot;first_name&quot;</span><span class="o">]</span> <span class="o">=</span> <span class="s2">&quot;Michael&quot;</span>     <span class="c1"># Clé &quot;first_name&quot;, valeur &quot;Michael&quot;</span>
<span class="go">=&gt; &quot;Michael&quot;</span>
<span class="gp">&gt;&gt; </span><span class="n">user</span><span class="o">[</span><span class="s2">&quot;last_name&quot;</span><span class="o">]</span> <span class="o">=</span> <span class="s2">&quot;Hartl&quot;</span>        <span class="c1"># Clé &quot;last_name&quot;, valeur &quot;Hartl&quot;</span>
<span class="go">=&gt; &quot;Hartl&quot;</span>
<span class="gp">&gt;&gt; </span><span class="n">user</span><span class="o">[</span><span class="s2">&quot;first_name&quot;</span><span class="o">]</span>                 <span class="c1"># L'accès aux éléments fonctionne comme</span>
<span class="go">=&gt; &quot;Michael&quot;</span>                          <span class="c1"># sur les tableaux.</span>
<span class="gp">&gt;&gt; </span><span class="n">user</span>                               <span class="c1"># Une représentation littérale de la</span>       
<span class="gp">&nbsp;&nbsp;&nbsp;</span><span class="n">&nbsp;</span>                                  <span class="c1"># table de hachage</span>
<span class="go">=&gt; {&quot;last_name&quot;=&gt;&quot;Hartl&quot;, &quot;first_name&quot;=&gt;&quot;Michael&quot;}</span>
</pre></div>
</div>


<p>Les tables de hachages sont indiquées avec des accolades contenant des paires clé-valeur&nbsp;; une paire d'accolades sans clé-valeurs &mdash;&nbsp;c'est-à-dire <code>{}</code>&nbsp;&mdash; est une table vide. Il est important de notre que les accolades pour les tables de hachage n'ont rien à voir avec les accolades pour les blocs (oui, ça peut être source de confusion). Bien que les tables de hachage ressemplent aux tableaux, une différence important est que les tables ne garantissent pas, généralement de garder leurs éléments dans un ordre particulier.<sup class="footnote" id="fnref:4.12"><a href="#fn:4.12">12</a></sup> Si l'ordre importe, utilisez un tableau.</p>

<p>Plutôt que de définir les tables de hachage un item à la fois en utilisant les crochets, il est facile d'utiliser leur représentation littérale&nbsp;:</p>

<div class="code"><div class="highlight"><pre><span class="gp">&gt;&gt; </span><span class="n">user</span> <span class="o">=</span> <span class="p">{</span> <span class="s2">&quot;first_name&quot;</span> <span class="o">=&gt;</span> <span class="s2">&quot;Michael&quot;</span><span class="p">,</span> <span class="s2">&quot;last_name&quot;</span> <span class="o">=&gt;</span> <span class="s2">&quot;Hartl&quot;</span> <span class="p">}</span>
<span class="go">=&gt; {&quot;last_name&quot;=&gt;&quot;Hartl&quot;, &quot;first_name&quot;=&gt;&quot;Michael&quot;}</span>
</pre></div>
</div>


<p>Ici j'ai utilisé la convention habituelle de Ruby de placer une extra espace<!-- "espace" est féminine en typo --> aux deux extrémités de la table de hachage &mdash;&nbsp;une convention ignorée par la sortie de la console… (ne me demandez pas pourquoi les espaces sont conventionnelles<!-- "espace" est féminin en type -->&nbsp;; probablement quelques programmeurs initiaux influants aimaient l'aspect des extra espaces, et la convention a pris).</p>

<p>Jusqu'ici nous avons utilisé des chaines comme clé de hachage, mais en Rails il est bien plus courant d'utiliser plutôt des <em>symbols</em>. Les symboles ressemblent aux chaines de caractères, mais sont préfixés par le signe «&nbsp;deux points&nbsp;» au lieu d'être entourés par des guillemets (simples ou doubles). Par exemple, <code>:nom</code> est un symbole. Vous pouvez basiquement penser les symboles comme des chaines sans le bagagge correspondant&nbsp;:<sup class="footnote" id="fnref:4.13"><a href="#fn:4.13">13</a></sup></p>

<div class="code"><div class="highlight"><pre><span class="gp">&gt;&gt; </span><span class="s2">&quot;nom&quot;</span><span class="o">.</span><span class="n">split</span><span class="p">(</span><span class="s1">&#39;&#39;</span><span class="p">)</span>
<span class="go">=&gt; [&quot;n&quot;, &quot;o&quot;, &quot;m&quot;]</span>
<span class="gp">&gt;&gt; </span><span class="ss">:nom</span><span class="o">.</span><span class="n">split</span><span class="p">(</span><span class="s1">&#39;&#39;</span><span class="p">)</span>
<span class="go">NoMethodError: undefined method `split&#39; for :name:Symbol</span>
<span class="c1">(Traduction&nbsp;:</span>
<span class="c1">ErreurAucuneMethode&nbsp;: méthode `split&#39; indéfinie pour le symbole :nom)</span>
<span class="gp">&gt;&gt; </span><span class="s2">&quot;foobar&quot;</span><span class="o">.</span><span class="n">reverse</span>
<span class="go">=&gt; &quot;raboof&quot;</span>
<span class="gp">&gt;&gt; </span><span class="ss">:foobar</span><span class="o">.</span><span class="n">reverse</span>
<span class="go">NoMethodError: undefined method `reverse&#39; for :foobar:Symbol</span>
<span class="c1">(Traduction&nbsp;:</span>
<span class="c1">ErreurAucuneMethode&nbsp;: méthode `reverse&#39; indéfinie pour le symbole :foobar)</span>
</pre></div>
</div>


<p>Les symboles sont un type de données spécial de Ruby partagé avec seulement quelques autres langages, donc ils peuvent sembler bizarres au début, mais Rails les utilise beaucoup, donc vous vous y habituerez vite.</p>

<p>En termes de symboles comme clé de table de hachage, nous pouvons définir une table <code>personne</code> comme suit&nbsp;:</p>

<div class="code"><div class="highlight"><pre><span class="gp">&gt;&gt; </span><span class="n">personne</span> <span class="o">=</span> <span class="p">{</span> <span class="ss">:nom</span> <span class="o">=&gt;</span> <span class="s2">&quot;Michael Hartl&quot;</span><span class="p">,</span> <span class="ss">:email</span> <span class="o">=&gt;</span> <span class="s2">&quot;michael@example.com&quot;</span> <span class="p">}</span>
<span class="go">=&gt; {:nom=&gt;&quot;Michael Hartl&quot;, :email=&gt;&quot;michael@example.com&quot;}</span>
<span class="gp">&gt;&gt; </span><span class="n">personne</span><span class="o">[</span><span class="ss">:nom</span><span class="o">]</span>               <span class="c1"># Accès à la valeur correspondant à :nom.</span>
<span class="go">=&gt; &quot;Michael Hartl&quot;</span>
<span class="gp">&gt;&gt; </span><span class="n">personne</span><span class="o">[</span><span class="ss">:password</span><span class="o">]</span>          <span class="c1"># Accès à la valeur d'une clé indéfinie.</span>
<span class="go">=&gt; nil</span>
</pre></div>
</div>


<p>Nous voyons ici, dans le dernier exemple, que la valeur pour une clé indéfinie est simplement la valeur <code>nil</code> (<em>nul</em>).</p>

<p>Les valeurs d'une table de hachage peuvent virtuellement être n'importe quoi, même d'autres tables de hachage, comme on peut le voir dans l'<a class="ref" href="rails-flavored-ruby#code:nested_hashes">extrait&nbsp;4.5</a>.</p>

<div class="label" id="code:nested_hashes"></div>


<div class="codelisting">
<div class="listing"><span class="header">Extrait 4.5.</span> <span class="description">Tables imbriquées.</span> </div>
<div class="code"><div class="highlight"><pre><span class="gp">&gt;&gt; </span><span class="n">params</span> <span class="o">=</span> <span class="p">{}</span>        <span class="c1"># Défini une table appelée &#39;params&#39; (raccourci pour &#39;paramètres&#39;).</span>
<span class="go">=&gt; {}</span>
<span class="gp">&gt;&gt; </span><span class="n">params</span><span class="o">[</span><span class="ss">:user</span><span class="o">]</span> <span class="o">=</span> <span class="p">{</span> <span class="ss">:nom</span> <span class="o">=&gt;</span> <span class="s2">&quot;Michael Hartl&quot;</span><span class="p">,</span> <span class="ss">:email</span> <span class="o">=&gt;</span> <span class="s2">&quot;mhartl@example.com&quot;</span> <span class="p">}</span>
<span class="go">=&gt; {:nom=&gt;&quot;Michael Hartl&quot;, :email=&gt;&quot;mhartl@example.com&quot;}</span>
<span class="gp">&gt;&gt; </span><span class="n">params</span>
<span class="go">=&gt; {:user=&gt;{:nom=&gt;&quot;Michael Hartl&quot;, :email=&gt;&quot;mhartl@example.com&quot;}}</span>
<span class="gp">&gt;&gt; </span> <span class="n">params</span><span class="o">[</span><span class="ss">:user</span><span class="o">][</span><span class="ss">:email</span><span class="o">]</span>
<span class="go">=&gt; &quot;mhartl@example.com&quot;</span>
</pre></div>
</div></div>


<p>Ces sortes de tables de table, ou <em>tables imbriquées</em>, sont intensivement utilisées par Rails, comme nous le verrons au début de la <a class="ref" href="sign-up#sec:signup_failure">section&nbsp;8.2</a>.</p>

<p>Comme pour les tableaux et les rangs, les tables de hachage répondent à la méthode <code>each</code>. Par exemple, considérons une table appelée <code>flash</code> avec des clés pour deux conditions, <code>:success</code> (<em>succès</em>) et <code>:error</code> (<em>erreur</em>)&nbsp;:</p>

<div class="code"><div class="highlight"><pre><span class="gp">&gt;&gt; </span><span class="n">flash</span> <span class="o">=</span> <span class="p">{</span> <span class="ss">:success</span> <span class="o">=&gt;</span> <span class="s2">&quot;Ça marche&nbsp;!&quot;</span><span class="p">,</span> <span class="ss">:error</span> <span class="o">=&gt;</span> <span class="s2">&quot;Raté… :-(&quot;</span> <span class="p">}</span>
<span class="go">=&gt; {:success=&gt;&quot;Ça marche&nbsp;!&quot;, :error=&gt;&quot;Raté… :-(&quot;}</span>
<span class="gp">&gt;&gt; </span><span class="n">flash</span><span class="o">.</span><span class="n">each</span> <span class="k">do</span> <span class="o">|</span><span class="n">key</span><span class="p">,</span> <span class="n">value</span><span class="o">|</span>
<span class="gp">?&gt; </span>  <span class="nb">puts</span> <span class="s2">&quot;La clé </span><span class="si">#{</span><span class="n">key</span><span class="o">.</span><span class="n">inspect</span><span class="si">}</span><span class="s2"> a la valeur value </span><span class="si">#{</span><span class="n">value</span><span class="o">.</span><span class="n">inspect</span><span class="si">}</span><span class="s2">&quot;</span>
<span class="gp">&gt;&gt; </span><span class="k">end</span>
<span class="go">La clé :success a la valeur &quot;Ça marche&nbsp;!&quot;</span>
<span class="go">La clé :error a la valeur &quot;Raté… :-(&quot;</span>
</pre></div>
</div>


<p>Notez que, tandis que la méthode <code>each</code> des tableaux prend un bloc avec une seule variable, <code>each</code> pour les tables de hachage en prend deux, une <em>clé</em> et une <em>valeur</em>. Ainsi, la méthode <code>each</code> pour les tables de hachage fait son itération à travers la table une <em>paire</em> clé-valeur à la fois.</p>

<p>L'exemple précédent utilise la méthode utile <code>inspect</code>, qui retourne une chaine avec une représentation littérale de l'objet qui l'appelle&nbsp;:</p>

<div class="code"><div class="highlight"><pre><span class="gp">&gt;&gt; </span><span class="nb">puts</span> <span class="p">(</span><span class="mi">1</span><span class="o">.</span><span class="n">.</span><span class="mi">5</span><span class="p">)</span><span class="o">.</span><span class="n">to_a</span>            <span class="c1"># Rend une liste comme chaine.</span>
<span class="go">1</span>
<span class="go">2</span>
<span class="go">3</span>
<span class="go">4</span>
<span class="go">5</span>
<span class="gp">&gt;&gt; </span><span class="nb">puts</span> <span class="p">(</span><span class="mi">1</span><span class="o">.</span><span class="n">.</span><span class="mi">5</span><span class="p">)</span><span class="o">.</span><span class="n">to_a</span><span class="o">.</span><span class="n">inspect</span>    <span class="c1"># Rend une liste littérale.</span>
<span class="go">[1, 2, 3, 4, 5]</span>
<span class="gp">&gt;&gt; </span><span class="nb">puts</span> <span class="ss">:name</span><span class="p">,</span> <span class="ss">:name</span><span class="o">.</span><span class="n">inspect</span>
<span class="go">name</span>
<span class="go">:name</span>
<span class="gp">&gt;&gt; </span><span class="nb">puts</span> <span class="s2">&quot;Ça marche&nbsp;!&quot;</span><span class="p">,</span> <span class="s2">&quot;Ça marche&nbsp;!&quot;</span><span class="o">.</span><span class="n">inspect</span>
<span class="go">Ça marche&nbsp;!</span>
<span class="go">&quot;Ça marche&nbsp;!&quot;</span>
</pre></div>
</div>


<p>En passant, utiliser <code>inspect</code> pour imprimer un objet est assez courant pour qu'il y ait un raccourci pour le faire, la fonction <code>p</code>&nbsp;:</p>

<div class="code"><div class="highlight"><pre><span class="gp">&gt;&gt; </span><span class="nb">p</span> <span class="ss">:name</span>             <span class="c1"># Identique à &#39;puts :name.inspect&#39;</span>
<span class="go">:name</span>
</pre></div>
</div>




<div class="label" id="sec:css_revisited"></div>


<h3><a id="sec:4.3.4" href="rails-flavored-ruby#sec:css_revisited" class="heading"><span class="number">4.3.4</span> CSS Revisité</a></h3>


<p>Il est temps maintenant de revisiter les lignes de l'<a class="ref" href="rails-flavored-ruby#code:layout_with_stylesheets">extrait&nbsp;4.4</a> utilisées dans le layout pour inclure les feuilles de styles en cascade&nbsp;:</p>

<div class="code"><div class="highlight"><pre><span class="cp">&lt;%=</span> <span class="n">stylesheet_link_tag</span> <span class="s1">&#39;blueprint/screen&#39;</span><span class="p">,</span> <span class="ss">:media</span> <span class="o">=&gt;</span> <span class="s1">&#39;screen&#39;</span> <span class="cp">%&gt;</span>
<span class="cp">&lt;%=</span> <span class="n">stylesheet_link_tag</span> <span class="s1">&#39;blueprint/print&#39;</span><span class="p">,</span>  <span class="ss">:media</span> <span class="o">=&gt;</span> <span class="s1">&#39;print&#39;</span> <span class="cp">%&gt;</span>
</pre></div>
</div>


<p>Nous sommes maintenant tout près de pouvoir les comprendre. Comme mentionné brièvement à la <a class="ref" href="rails-flavored-ruby#sec:cascading_style_sheets">section&nbsp;4.1.2</a>, Rails définit une fonction spéciale pour inclure les feuilles de styles, et… </p>

<div class="code"><div class="highlight"><pre><span class="n">stylesheet_link_tag</span> <span class="s1">&#39;blueprint/screen&#39;</span><span class="p">,</span> <span class="ss">:media</span> <span class="o">=&gt;</span> <span class="s1">&#39;screen&#39;</span>
</pre></div>
</div>


<p>… est un appel à cette fonction. Mais il demeure deux mystères. <em>Primo</em>, où sont les parenthèses&nbsp;? En Ruby, elles sont optionnelles&nbsp;; ces deux lignes sont équivalentes&nbsp;:</p>

<div class="code"><div class="highlight"><pre><span class="c1"># Les parenthèses optionnelles à l'appel de la fonction.</span>
<span class="n">stylesheet_link_tag</span><span class="p">(</span><span class="s1">&#39;blueprint/screen&#39;</span><span class="p">,</span> <span class="ss">:media</span> <span class="o">=&gt;</span> <span class="s1">&#39;screen&#39;</span><span class="p">)</span>
<span class="n">stylesheet_link_tag</span> <span class="s1">&#39;blueprint/screen&#39;</span><span class="p">,</span> <span class="ss">:media</span> <span class="o">=&gt;</span> <span class="s1">&#39;screen&#39;</span>
</pre></div>
</div>


<p><em>Secondo</em>, l'argument <code>:media</code> ressemble à une table de hachage, mais où sont les accolades&nbsp;? Quand des tables de hachage sont le  <em>dernier</em> argument de l'appel d'une fonction, les accolades sont optionnelles&nbsp;; ces deux lignes sont donc équivalentes:</p>

<div class="code"><div class="highlight"><pre><span class="c1"># Accolades optionnelles sur l'argument final.</span>
<span class="n">stylesheet_link_tag</span> <span class="s1">&#39;blueprint/screen&#39;</span><span class="p">,</span> <span class="p">{</span> <span class="ss">:media</span> <span class="o">=&gt;</span> <span class="s1">&#39;screen&#39;</span> <span class="p">}</span>
<span class="n">stylesheet_link_tag</span> <span class="s1">&#39;blueprint/screen&#39;</span><span class="p">,</span> <span class="ss">:media</span> <span class="o">=&gt;</span> <span class="s1">&#39;screen&#39;</span>
</pre></div>
</div>


<p>Donc, nous voyons maintenant que chacune des lignes…</p>

<div class="code"><div class="highlight"><pre><span class="cp">&lt;%=</span> <span class="n">stylesheet_link_tag</span> <span class="s1">&#39;blueprint/screen&#39;</span><span class="p">,</span> <span class="ss">:media</span> <span class="o">=&gt;</span> <span class="s1">&#39;screen&#39;</span> <span class="cp">%&gt;</span>
<span class="cp">&lt;%=</span> <span class="n">stylesheet_link_tag</span> <span class="s1">&#39;blueprint/print&#39;</span><span class="p">,</span>  <span class="ss">:media</span> <span class="o">=&gt;</span> <span class="s1">&#39;print&#39;</span> <span class="cp">%&gt;</span>
</pre></div>
</div>


<p>… appellent la fonction <code>stylesheet_link_tag</code> avec deux arguments&nbsp;: une chaine de caractères, indiquant le chemin d'accès au fichier de la feuille de styles CSS, et une table de hachage, indiquant le type de média concerné (<code>&rsquo;screen&rsquo;</code> pour l'écran de l'ordinateur et <code>&rsquo;print&rsquo;</code> pour la version imprimée). Grâce au balisage <tt class="verb">&lt;%= %&gt;</tt>, les résultats sont insérés dans le template par ERb, et si vous regardez le code source de la page dans votre navigateur vous pourrez voir le code nécessaire pour inclure une feuille de styles (<a class="ref" href="rails-flavored-ruby#code:css_source">extrait&nbsp;4.6</a>).<sup class="footnote" id="fnref:4.14"><a href="#fn:4.14">14</a></sup></p>

<div class="label" id="code:css_source"></div>


<div class="codelisting">
<div class="listing"><span class="header">Extrait 4.6.</span> <span class="description">Le code HTML produit par l'inclusion d'une CSS.</span>       
</div>
<div class="code"><div class="highlight"><pre><span class="nt">&lt;link</span> <span class="na">href=</span><span class="s">&quot;/stylesheets/blueprint/screen.css&quot;</span> <span class="na">media=</span><span class="s">&quot;screen&quot;</span> <span class="na">rel=</span><span class="s">&quot;stylesheet&quot;</span>
<span class="na">type=</span><span class="s">&quot;text/css&quot;</span> <span class="nt">/&gt;</span>
<span class="nt">&lt;link</span> <span class="na">href=</span><span class="s">&quot;/stylesheets/blueprint/print.css&quot;</span> <span class="na">media=</span><span class="s">&quot;print&quot;</span> <span class="na">rel=</span><span class="s">&quot;stylesheet&quot;</span>
<span class="na">type=</span><span class="s">&quot;text/css&quot;</span> <span class="nt">/&gt;</span>
</pre></div>
</div></div>




<div class="label" id="sec:ruby_classes"></div>


<h2><a id="sec:4.4" href="rails-flavored-ruby#sec:ruby_classes" class="heading"><span class="number">4.4</span> Classes Ruby</a></h2>


<p>Nous avons dit auparavant que tout dans Ruby était un objet, et dans cette section nous seront amenés à définir les nôtres. Ruby, comme beaucoup de language orienté-objet, utilises les <em>classes</em> pour organiser les méthodes&nbsp;; ces classes sont alors <em>instanciées</em> pour créer des objets. Si vous êtes débutant en programmation orienté-objet (POO), cela peut ressembler à du charabia, donc étudions quelques exemples concrets.</p>

<div class="label" id="sec:constructors"></div>


<h3><a id="sec:4.4.1" href="rails-flavored-ruby#sec:constructors" class="heading"><span class="number">4.4.1</span> Constructeurs</a></h3>


<p>Nous avons vu beaucoup d'exemples d'utilisation des classes pour instancier des objets, mais nous devons encore le faire de façon explicite. Par exemple, nous avons instancié une chaine de caractère en utilisant les guillemets, qui est le <em>constructeur littéral</em> de chaines&nbsp;:</p>

<div class="code"><div class="highlight"><pre><span class="gp">&gt;&gt; </span><span class="n">s</span> <span class="o">=</span> <span class="s2">&quot;foobar&quot;</span>       <span class="c1"># Un constructeur littéral de chaine utilisant les guillemets</span>
<span class="go">=&gt; &quot;foobar&quot;</span>
<span class="gp">&gt;&gt; </span><span class="n">s</span><span class="o">.</span><span class="n">class</span>
<span class="go">=&gt; String</span>
</pre></div>
</div>


<p>Nous voyons ici que la chaine répond à la méthode <code>class</code>, et retourne simplement la classe à laquelle elle appartient («&nbsp;String&nbsp;», <em>Chaine</em>).</p>

<p>Plutôt que d'utiliser un constructeur littéral, nous pouvons utiliser le <em>contructeur nommé</em> équivalent, ce qui implique d'appeler la méthode <code>new</code> sur le nom de la classe&nbsp;:<sup class="footnote" id="fnref:4.15"><a href="#fn:4.15">15</a></sup></p>

<div class="code"><div class="highlight"><pre><span class="gp">&gt;&gt; </span><span class="n">s</span> <span class="o">=</span> <span class="nb">String</span><span class="o">.</span><span class="n">new</span><span class="p">(</span><span class="s2">&quot;foobar&quot;</span><span class="p">)</span>   <span class="c1"># Un constructeur nommé pour les chaines</span>
<span class="go">=&gt; &quot;foobar&quot;</span>
<span class="gp">&gt;&gt; </span><span class="n">s</span><span class="o">.</span><span class="n">class</span>
<span class="go">=&gt; String</span>
<span class="gp">&gt;&gt; </span><span class="n">s</span> <span class="o">==</span> <span class="s2">&quot;foobar&quot;</span>
<span class="go">=&gt; true</span>
</pre></div>
</div>


<p>C'est équivalent au constructeur littéral, mais c'est plus explicite sur ce que nous faisons.</p>

<p>Les Tableaux fonctionnent de la même façon que les chaines&nbsp;:</p>

<div class="code"><div class="highlight"><pre><span class="gp">&gt;&gt; </span><span class="n">a</span> <span class="o">=</span> <span class="nb">Array</span><span class="o">.</span><span class="n">new</span><span class="p">(</span><span class="o">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">2</span><span class="o">]</span><span class="p">)</span>
<span class="go">=&gt; [1, 3, 2]</span>
</pre></div>
</div>


<p>Les Tables de hachage, en revanche, sont différentes. Tandis que le constructeur de tableau <code>Array.new</code> prend une valeur initiale pour le tableau, <code>Hash.new</code> prend une valeur <em>par défaut</em> pour la table, qui est la valeur de la table pour une clé inexistante&nbsp;:</p>

<div class="code"><div class="highlight"><pre><span class="gp">&gt;&gt; </span><span class="n">h</span> <span class="o">=</span> <span class="no">Hash</span><span class="o">.</span><span class="n">new</span>
<span class="go">=&gt; {}</span>
<span class="gp">&gt;&gt; </span><span class="n">h</span><span class="o">[</span><span class="ss">:foo</span><span class="o">]</span>            <span class="c1"># Essai d'accès à la valeur d'une clé :foo inexistante.</span>
<span class="go">=&gt; nil</span>
<span class="gp">&gt;&gt; </span><span class="n">h</span> <span class="o">=</span> <span class="no">Hash</span><span class="o">.</span><span class="n">new</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span>    <span class="c1"># Arrangement pour que les clés inexistantes retournent 0 plutôt que nil.</span>
<span class="go">=&gt; {}</span>
<span class="gp">&gt;&gt; </span><span class="n">h</span><span class="o">[</span><span class="ss">:foo</span><span class="o">]</span>
<span class="go">=&gt; 0</span>
</pre></div>
</div>




<div class="label" id="sec:a_class_of_our_own"></div>


<h3><a id="sec:4.4.2" href="rails-flavored-ruby#sec:a_class_of_our_own" class="heading"><span class="number">4.4.2</span> Héritage de classe</a></h3>


<p>Quand on apprend les classes, c'est utilie de trouver la <em>hiérarchie de classe</em> en utilisant la méthode <code>superclass</code>&nbsp;:</p>

<div class="code"><div class="highlight"><pre><span class="gp">&gt;&gt; </span><span class="n">s</span> <span class="o">=</span> <span class="nb">String</span><span class="o">.</span><span class="n">new</span><span class="p">(</span><span class="s2">&quot;foobar&quot;</span><span class="p">)</span>
<span class="go">=&gt; &quot;foobar&quot;</span>
<span class="gp">&gt;&gt; </span><span class="n">s</span><span class="o">.</span><span class="n">class</span>                        <span class="c1"># Trouver la classe de s.</span>
<span class="go">=&gt; String</span>
<span class="gp">&gt;&gt; </span><span class="n">s</span><span class="o">.</span><span class="n">class</span><span class="o">.</span><span class="n">superclass</span>             <span class="c1"># Trouver la superclasse de la classe String.</span>
<span class="go">=&gt; Object</span>
<span class="gp">&gt;&gt; </span><span class="n">s</span><span class="o">.</span><span class="n">class</span><span class="o">.</span><span class="n">superclass</span><span class="o">.</span><span class="n">superclass</span>  <span class="c1"># Ruby 1.9 utilise une nouvea classe de base BasicObject</span>
<span class="go">=&gt; BasicObject </span>
<span class="gp">&gt;&gt; </span><span class="n">s</span><span class="o">.</span><span class="n">class</span><span class="o">.</span><span class="n">superclass</span><span class="o">.</span><span class="n">superclass</span><span class="o">.</span><span class="n">superclass</span>
<span class="go">=&gt; nil</span>
</pre></div>
</div>


<p>Dans le diagramme de cette héritage hiérarchique dans l<a class="ref" href="rails-flavored-ruby#fig:string_inheritance_ruby_1_9">illustration&nbsp;4.2</a>, nous voyons que la superclasse de <code>String</code> (<em>Chaine</em>) est la classe <code>Object</code> et la superclasse de la classe <code>Object</code> est la classe <code>BasicObject</code>, mais  <code>BasicObject</code> ne possède pas de superclasse. Ce modèle est vrai pour chaque objet Ruby&nbsp;: remontez la hiérarchie des classes assez loin, et chaque classe Ruby héritera en fin de compte de la classe <code>BasicObject</code>, qui n'a pas de superclasse elle-même. C'est l'explication technique de &ldquo;tout en Ruby est objet&rdquo;.</p>

<div class="label" id="fig:string_inheritance_ruby_1_9"></div>


<div class="figure"><div class="center"><span class="graphic"><img src="/images/figures/string_inheritance_ruby_1_9.png" alt="string_inheritance_ruby_1_9" /></span></div><div class="caption"><span class="header">Illustration 4.2: </span><span class="description">La hiérarchie des héritages pour la classe <code>String</code>.</span></div></div>


<p>Pour comprendre les classes un peu plus profondément, il n'y a rien de mieux que de construire les nôtres. Construison une classe <code>Mot</code> possédant une méthode <code>palindrome?</code> qui retourne <code>true</code> (<em>vrai</em>) si le mot est un palindrome (s'il s'épelle de la même façon à l'endroit et à l'envers)&nbsp;:</p>

<div class="code"><div class="highlight"><pre><span class="gp">&gt;&gt; </span><span class="k">class</span> <span class="nc">Mot</span>
<span class="gp">&gt;&gt; </span>  <span class="k">def</span> <span class="nf">palindrome?</span><span class="p">(</span><span class="n">string</span><span class="p">)</span>
<span class="gp">&gt;&gt; </span>    <span class="n">string</span> <span class="o">==</span> <span class="n">string</span><span class="o">.</span><span class="n">reverse</span>
<span class="gp">&gt;&gt; </span>  <span class="k">end</span>
<span class="gp">&gt;&gt; </span><span class="k">end</span>
<span class="go">=&gt; nil</span>
</pre></div>
</div>


<p>Nous pouvons l'utiliser comme suit&nbsp;:</p>

<div class="code"><div class="highlight"><pre><span class="gp">&gt;&gt; </span><span class="n">w</span> <span class="o">=</span> <span class="no">Mot</span><span class="o">.</span><span class="n">new</span>              <span class="c1"># Fait un nouvel objet Mot.</span>
<span class="go">=&gt; #&lt;Mot:0x22d0b20&gt;</span>
<span class="gp">&gt;&gt; </span><span class="n">w</span><span class="o">.</span><span class="n">palindrome?</span><span class="p">(</span><span class="s2">&quot;foobar&quot;</span><span class="p">)</span>
<span class="go">=&gt; false</span>
<span class="gp">&gt;&gt; </span><span class="n">w</span><span class="o">.</span><span class="n">palindrome?</span><span class="p">(</span><span class="s2">&quot;level&quot;</span><span class="p">)</span>
<span class="go">=&gt; true</span>
</pre></div>
</div>


<p>Si cet exemple vous semble un peu artificiel, tant mieux&nbsp;; c'est à dessein. C'est étrange de créer une nouvelle classe jue pour créer une méthode qui prend une chaine de caractère comme argument. Puisqu'un mot <em>est une</em> chaine de caractères, il semble naturel que notre classe <code>Word</code> <em>hérite</em> de la classe <code>String</code>, comme nous le voyons dans <a class="ref" href="rails-flavored-ruby#code:word_class">extrait&nbsp;4.7</a> (vous devriez quitter la console et la relancer pour effacer l'ancienne définition de  <code>Mot</code>).</p>

<div class="label" id="code:word_class"></div>


<div class="codelisting">
<div class="listing"><span class="header">Extrait 4.7.</span> <span class="description">Définir une classe <code>Mot</code> dans la console.</span> </div>
<div class="code"><div class="highlight"><pre><span class="gp">&gt;&gt; </span><span class="k">class</span> <span class="nc">Mot</span> <span class="o">&lt;</span> <span class="nb">String</span>             <span class="c1"># Mot hérite de String.</span>
<span class="gp">&gt;&gt; </span>  <span class="c1"># Renvoie true si la chaine est son propre inverse.</span>
<span class="gp">&gt;&gt; </span>  <span class="k">def</span> <span class="nf">palindrome?</span>
<span class="gp">&gt;&gt; </span>    <span class="nb">self</span> <span class="o">==</span> <span class="nb">self</span><span class="o">.</span><span class="n">reverse</span>        <span class="c1"># self est la chaine elle-même.</span>
<span class="gp">&gt;&gt; </span>  <span class="k">end</span>
<span class="gp">&gt;&gt; </span><span class="k">end</span>
<span class="go">=&gt; nil</span>
</pre></div>
</div></div>


<p>Ici <code>Mot &lt; String</code> est la syntaxe Ruby l'héritage (discuté brièvement à la <a class="ref" href="static-pages#sec:static_pages_with_rails">section&nbsp;3.1.2</a>), qui s'assure que, en plus de la nouvelle méthode <code>palindrome?</code>, les mots héritent des mêmes méthodes que les chaines de caractères&nbsp;:</p>

<div class="code"><div class="highlight"><pre><span class="gp">&gt;&gt; </span><span class="n">s</span> <span class="o">=</span> <span class="no">Mot</span><span class="o">.</span><span class="n">new</span><span class="p">(</span><span class="s2">&quot;level&quot;</span><span class="p">)</span>    <span class="c1"># Fait un nouveau Mot, initialisé à  &quot;level&quot;.</span>
<span class="go">=&gt; &quot;level&quot;                  </span>
<span class="gp">&gt;&gt; </span><span class="n">s</span><span class="o">.</span><span class="n">palindrome?</span>            <span class="c1"># Mots possèdent la méthode palindrome?.</span>
<span class="go">=&gt; true                     </span>
<span class="gp">&gt;&gt; </span><span class="n">s</span><span class="o">.</span><span class="n">length</span>                 <span class="c1"># Mots héritent aussi de toutes les méthodes des chaines.</span>
<span class="go">=&gt; 5</span>
</pre></div>
</div>


<p>Puisque la classe <code>Mot</code> hérite de la classe <code>String</code>, nous pouvons utiliser la console pour voir la hiérarchie des classes explicitement&nbsp;:</p>

<div class="code"><div class="highlight"><pre><span class="gp">&gt;&gt; </span><span class="n">s</span><span class="o">.</span><span class="n">class</span>
<span class="go">=&gt; Mot</span>
<span class="gp">&gt;&gt; </span><span class="n">s</span><span class="o">.</span><span class="n">class</span><span class="o">.</span><span class="n">superclass</span>
<span class="go">=&gt; String</span>
<span class="gp">&gt;&gt; </span><span class="n">s</span><span class="o">.</span><span class="n">class</span><span class="o">.</span><span class="n">superclass</span><span class="o">.</span><span class="n">superclass</span>
<span class="go">=&gt; Object</span>
</pre></div>
</div>


<p>Cette hiérarchie est présentée dans l'<a class="ref" href="rails-flavored-ruby#fig:word_inheritance_ruby_1_9">illustration&nbsp;4.3</a>.</p>

<div class="label" id="fig:word_inheritance_ruby_1_9"></div>


<div class="figure"><div class="center"><span class="graphic"><img src="/images/figures/word_inheritance_ruby_1_9.png" alt="word_inheritance_ruby_1_9" /></span></div><div class="caption"><span class="header">Illustration 4.3: </span><span class="description">La hiérarchie de l'héritage pour une classe (non-intégré) <code>Mot</code> de l'<a class="ref" href="rails-flavored-ruby#code:word_class">extrait&nbsp;4.7</a>.</span></div></div>


<p>Dans l'<a class="ref" href="rails-flavored-ruby#code:word_class">extrait&nbsp;4.7</a>, notez que vérifier que le mot est son propre inverse implique d'avoir accès au mot à l'intérieur de la classe <code>Mot</code>. Ruby nous permet de le faire en utilisant le mot-clé <code>self</code>&nbsp;: à l'intérieur de la classe <code>Mot</code>, <code>self</code> est l'objet lui-même, ce qui signifie que nous pouvons utiliser…</p>

<div class="code"><div class="highlight"><pre><span class="nb">self</span> <span class="o">==</span> <span class="nb">self</span><span class="o">.</span><span class="n">reverse</span>
</pre></div>
</div>


<p>… pour vérifier que le mot est un palindrome.<sup class="footnote" id="fnref:4.16"><a href="#fn:4.16">16</a></sup></p>

<div class="label" id="sec:modifying_built_in_classes"></div>

<!-- FIN FRENCH -->

<h3><a id="sec:4.4.3" href="rails-flavored-ruby#sec:modifying_built_in_classes" class="heading"><span class="number">4.4.3</span> Modifier les classes d'origine</a></h3>


<p>While inheritance is a powerful idea, in the case of palindromes it might be even more natural to add the <code>palindrome?</code> method to the <code>String</code> class itself, so that (among other things) we can call <code>palindrome?</code> on a string literal, which we currently can&rsquo;t do:</p>

<div class="code"><div class="highlight"><pre><span class="gp">&gt;&gt; </span><span class="s2">&quot;level&quot;</span><span class="o">.</span><span class="n">palindrome?</span>
<span class="go">NoMethodError: undefined method `palindrome?&#39; for &quot;level&quot;:String</span>
</pre></div>
</div>


<p>Somewhat amazingly, Ruby lets you do just this; Ruby classes can be <em>opened</em> and modified, allowing ordinary mortals such as ourselves to add methods to them:<sup class="footnote" id="fnref:4.17"><a href="#fn:4.17">17</a></sup></p>

<div class="code"><div class="highlight"><pre><span class="gp">&gt;&gt; </span><span class="k">class</span> <span class="nc">String</span>
<span class="gp">&gt;&gt; </span>  <span class="c1"># Return true if the string is its own reverse.</span>
<span class="gp">&gt;&gt; </span>  <span class="k">def</span> <span class="nf">palindrome?</span>
<span class="gp">&gt;&gt; </span>    <span class="nb">self</span> <span class="o">==</span> <span class="nb">self</span><span class="o">.</span><span class="n">reverse</span>
<span class="gp">&gt;&gt; </span>  <span class="k">end</span>
<span class="gp">&gt;&gt; </span><span class="k">end</span>
<span class="go">=&gt; nil</span>
<span class="gp">&gt;&gt; </span><span class="s2">&quot;deified&quot;</span><span class="o">.</span><span class="n">palindrome?</span>
<span class="go">=&gt; true</span>
</pre></div>
</div>


<p>(I don&rsquo;t know which is cooler: that Ruby lets you add methods to intégré classes, or that <code>"deified"</code> is a palindrome.)</p>

<p>Modifying intégré classes is a powerful technique, but with great power comes great responsibility, and it&rsquo;s considered bad form to add methods to intégré classes without having a <em>really</em> good reason for doing so. Rails does have some good reasons; for example, in web applications we often want to prevent variables from being <em>blank</em>&mdash;e.g., a user&rsquo;s name should be something other than spaces and other <a href="http://en.wikipedia.org/wiki/Whitespace_(computer_science)">whitespace</a>&mdash;so Rails adds a <code>blank?</code> method to Ruby. Since the Rails console automatically includes the Rails extensions, we can see an example here (this won&rsquo;t work in plain <code>irb</code>):</p>

<div class="code"><div class="highlight"><pre><span class="gp">&gt;&gt; </span><span class="s2">&quot;&quot;</span><span class="o">.</span><span class="n">blank?</span>
<span class="go">=&gt; true</span>
<span class="gp">&gt;&gt; </span><span class="s2">&quot;      &quot;</span><span class="o">.</span><span class="n">empty?</span>
<span class="go">=&gt; false</span>
<span class="gp">&gt;&gt; </span><span class="s2">&quot;      &quot;</span><span class="o">.</span><span class="n">blank?</span>
<span class="go">=&gt; true</span>
<span class="gp">&gt;&gt; </span><span class="kp">nil</span><span class="o">.</span><span class="n">blank?</span>
<span class="go">=&gt; true</span>
</pre></div>
</div>


<p>We see that a string of spaces is not <em>empty</em>, but it is <em>blank</em>. Note also that <code>nil</code> is blank; since <code>nil</code> isn&rsquo;t a string, this is a hint that Rails actually adds <code>blank?</code> to <code>String</code>&rsquo;s base class, which (as we saw at the beginning of this section) is <code>Object</code> itself. We&rsquo;ll see some other examples of Rails additions to Ruby classes in <a class="ref" href="sign-in-sign-out#sec:remember_me">section&nbsp;9.3.2</a>.</p>

<div class="label" id="sec:a_controller_class"></div>


<h3><a id="sec:4.4.4" href="rails-flavored-ruby#sec:a_controller_class" class="heading"><span class="number">4.4.4</span> A controller class</a></h3>


<p>All this talk about classes and inheritance may have triggered a flash of recognition, because we have seen both before, in the Pages controller (<a class="ref" href="static-pages#code:pages_controller_with_title">extrait&nbsp;3.24</a>):</p>

<div class="code"><div class="highlight"><pre><span class="k">class</span> <span class="nc">PagesController</span> <span class="o">&lt;</span> <span class="no">ApplicationController</span>

  <span class="k">def</span> <span class="nf">home</span>
    <span class="vi">@title</span> <span class="o">=</span> <span class="s2">&quot;Home&quot;</span>
  <span class="k">end</span>

  <span class="k">def</span> <span class="nf">contact</span>
    <span class="vi">@title</span> <span class="o">=</span> <span class="s2">&quot;Contact&quot;</span>
  <span class="k">end</span>

  <span class="k">def</span> <span class="nf">about</span>
    <span class="vi">@title</span> <span class="o">=</span> <span class="s2">&quot;About&quot;</span>
  <span class="k">end</span>
<span class="k">end</span>
</pre></div>
</div>


<p>You&rsquo;re now in a position to appreciate, at least vaguely, what this code means: <code>PagesController</code> is a class that inherits from <code>ApplicationController</code>, and comes equipped with <code>home</code>, <code>contact</code>, and <code>about</code> methods, each of which defines the instance variable <code>@title</code>. Since each Rails console session loads the local Rails environment, we can even create a controller explicitly and examine its class hierarchy:<sup class="footnote" id="fnref:4.18"><a href="#fn:4.18">18</a></sup></p>

<div class="code"><div class="highlight"><pre><span class="gp">&gt;&gt; </span><span class="n">controller</span> <span class="o">=</span> <span class="no">PagesController</span><span class="o">.</span><span class="n">new</span>
<span class="go">=&gt; #&lt;PagesController:0x22855d0&gt;</span>
<span class="gp">&gt;&gt; </span><span class="n">controller</span><span class="o">.</span><span class="n">class</span>
<span class="go">=&gt; PagesController</span>
<span class="gp">&gt;&gt; </span><span class="n">controller</span><span class="o">.</span><span class="n">class</span><span class="o">.</span><span class="n">superclass</span>
<span class="go">=&gt; ApplicationController</span>
<span class="gp">&gt;&gt; </span><span class="n">controller</span><span class="o">.</span><span class="n">class</span><span class="o">.</span><span class="n">superclass</span><span class="o">.</span><span class="n">superclass</span>
<span class="go">=&gt; ActionController::Base</span>
<span class="gp">&gt;&gt; </span><span class="n">controller</span><span class="o">.</span><span class="n">class</span><span class="o">.</span><span class="n">superclass</span><span class="o">.</span><span class="n">superclass</span><span class="o">.</span><span class="n">superclass</span>
<span class="go">=&gt; ActionController::Metal</span>
<span class="gp">&gt;&gt; </span><span class="n">controller</span><span class="o">.</span><span class="n">class</span><span class="o">.</span><span class="n">superclass</span><span class="o">.</span><span class="n">superclass</span><span class="o">.</span><span class="n">superclass</span><span class="o">.</span><span class="n">superclass</span>
<span class="go">=&gt; AbstractController::Base</span>
<span class="gp">&gt;&gt; </span><span class="n">controller</span><span class="o">.</span><span class="n">class</span><span class="o">.</span><span class="n">superclass</span><span class="o">.</span><span class="n">superclass</span><span class="o">.</span><span class="n">superclass</span><span class="o">.</span><span class="n">superclass</span><span class="o">.</span><span class="n">superclass</span>
<span class="go">=&gt; Object</span>
</pre></div>
</div>


<p>A diagram of this hierarchy appears in <a class="ref" href="rails-flavored-ruby#fig:pages_controller_inheritance_rails_3">illustration&nbsp;4.4</a>.</p>

<div class="label" id="fig:pages_controller_inheritance_rails_3"></div>


<div class="figure"><div class="center"><span class="graphic"><img src="/images/figures/pages_controller_inheritance_rails_3.png" alt="pages_controller_inheritance_rails_3" /></span></div><div class="caption"><span class="header">Illustration 4.4: </span><span class="description">The inheritance hierarchy for the Pages controller.</span></div></div>


<p>We can even call the controller actions inside the console, which are just methods:</p>

<div class="code"><div class="highlight"><pre><span class="gp">&gt;&gt; </span><span class="n">controller</span><span class="o">.</span><span class="n">home</span>
<span class="go">=&gt; &quot;Home&quot;</span>
</pre></div>
</div>


<p>This return value of <code>"Home"</code> comes from the assignment <code>@title = "Home"</code> in the <code>home</code> action.</p>

<p>But wait&mdash;actions don&rsquo;t have return values, at least not ones that matter. The point of the <code>home</code> action, as we saw in <a class="ref" href="static-pages#top">chapitre&nbsp;3</a>, is to render a web page. And I sure don&rsquo;t remember ever calling <code>PagesController.new</code> anywhere. What&rsquo;s going on?</p>

<p>What&rsquo;s going on is that Rails is <em>written in</em> Ruby, but Rails isn&rsquo;t Ruby. Some Rails classes are used like ordinary Ruby objects, but some are just <a href="http://www.answers.com/grist">grist</a> for Rails&rsquo; magic mill. Rails is <a href="http://en.wikipedia.org/wiki/Sui_generis"><em>sui generis</em></a>, and should be studied and understood separately from Ruby. This is why, if your principal programming interest is writing web applications, I recommend learning Rails first, then learning Ruby, then looping back to Rails.</p>

<div class="label" id="sec:a_user_class"></div>


<h3><a id="sec:4.4.5" href="rails-flavored-ruby#sec:a_user_class" class="heading"><span class="number">4.4.5</span> A user class</a></h3>


<p>We end our tour of Ruby with a complete class of our own, a <code>User</code> class that anticipates the User model coming up in <a class="ref" href="modeling-and-viewing-users-one#top">chapitre&nbsp;6</a>.</p>

<p>So far we&rsquo;ve entered class definitions at the console, but this quickly becomes tiresome; instead, create the file <code>example_user.rb</code> in your Rails root directory and fill it with the contents of <a class="ref" href="rails-flavored-ruby#code:example_user">extrait&nbsp;4.8</a>. (Recall from <a class="ref" href="beginning#sec:conventions">section&nbsp;1.1.3</a> that the Rails root is the root of your <em>application</em> directory; for example, the Rails root for my sample application is <tt>/Users/mhartl/rails_projects/sample_app</tt>.)</p>

<div class="label" id="code:example_user"></div>


<div class="codelisting">
<div class="listing"><span class="header">Extrait 4.8.</span> <span class="description">Code for an example user. <br /> <code>example_user.rb</code></span>       
</div>
<div class="code"><div class="highlight"><pre><span class="k">class</span> <span class="nc">User</span>
  <span class="kp">attr_accessor</span> <span class="ss">:name</span><span class="p">,</span> <span class="ss">:email</span>

  <span class="k">def</span> <span class="nf">initialize</span><span class="p">(</span><span class="n">attributes</span> <span class="o">=</span> <span class="p">{})</span>
    <span class="vi">@name</span>  <span class="o">=</span> <span class="n">attributes</span><span class="o">[</span><span class="ss">:name</span><span class="o">]</span>
    <span class="vi">@email</span> <span class="o">=</span> <span class="n">attributes</span><span class="o">[</span><span class="ss">:email</span><span class="o">]</span>
  <span class="k">end</span>

  <span class="k">def</span> <span class="nf">formatted_email</span>
    <span class="s2">&quot;</span><span class="si">#{</span><span class="vi">@name</span><span class="si">}</span><span class="s2"> &lt;</span><span class="si">#{</span><span class="vi">@email</span><span class="si">}</span><span class="s2">&gt;&quot;</span>
  <span class="k">end</span>
<span class="k">end</span>
</pre></div>
</div></div>


<p>There&rsquo;s quite a bit going on here, so let&rsquo;s take it step by step. The first line,</p>

<div class="code"><div class="highlight"><pre>  <span class="kp">attr_accessor</span> <span class="ss">:name</span><span class="p">,</span> <span class="ss">:email</span>
</pre></div>
</div>


<p>creates <em>attribute accessors</em> corresponding to a user&rsquo;s name and email address. This creates &ldquo;getter&rdquo; and &ldquo;setter&rdquo; methods that allow us to retrieve (get) and assign (set) <code>@name</code> and <code>@email</code> instance variables.</p>

<p>The first method, <code>initialize</code>, is special in Ruby: it&rsquo;s the method called when we execute <code>User.new</code>. This particular <code>initialize</code> takes one argument, <code>attributes</code>:</p>

<div class="code"><div class="highlight"><pre>  <span class="k">def</span> <span class="nf">initialize</span><span class="p">(</span><span class="n">attributes</span> <span class="o">=</span> <span class="p">{})</span>
    <span class="vi">@name</span>  <span class="o">=</span> <span class="n">attributes</span><span class="o">[</span><span class="ss">:name</span><span class="o">]</span>
    <span class="vi">@email</span> <span class="o">=</span> <span class="n">attributes</span><span class="o">[</span><span class="ss">:email</span><span class="o">]</span>
  <span class="k">end</span>
</pre></div>
</div>


<p>Here the <code>attributes</code> variable has a <em>default value</em> equal to the empty hash, so that we can define a user with no name or email address (recall from <a class="ref" href="rails-flavored-ruby#sec:hashes_and_symbols">section&nbsp;4.3.3</a> that hashes return <code>nil</code> for nonexistent keys, so <code>attributes[:name]</code> will be <code>nil</code> if there is no <code>:name</code> key, and similarly for <code>attributes[:email]</code>).</p>

<p>Finally, our class defines a method called <code>formatted_email</code> that uses the values of the assigned <code>@name</code> and <code>@email</code> variables to build up a nicely formatted version of the user&rsquo;s email address using string interpolation (<a class="ref" href="rails-flavored-ruby#sec:strings">section&nbsp;4.2.2</a>):</p>

<div class="code"><div class="highlight"><pre>  <span class="k">def</span> <span class="nf">formatted_email</span>
    <span class="s2">&quot;</span><span class="si">#{</span><span class="vi">@name</span><span class="si">}</span><span class="s2"> &lt;</span><span class="si">#{</span><span class="vi">@email</span><span class="si">}</span><span class="s2">&gt;&quot;</span>
  <span class="k">end</span>
</pre></div>
</div>


<p>Let&rsquo;s fire up the console, <code>require</code> the example user code, and take our User class out for a spin:</p>

<div class="code"><div class="highlight"><pre><span class="gp">&gt;&gt; </span><span class="nb">require</span> <span class="s1">&#39;./example_user&#39;</span>     <span class="c1"># This is how you load the example_user code.</span>
<span class="go">=&gt; [&quot;User&quot;]</span>
<span class="gp">&gt;&gt; </span><span class="n">example</span> <span class="o">=</span> <span class="no">User</span><span class="o">.</span><span class="n">new</span>
<span class="go">=&gt; #&lt;User:0x224ceec @email=nil, @name=nil&gt;</span>
<span class="gp">&gt;&gt; </span><span class="n">example</span><span class="o">.</span><span class="n">name</span>                 <span class="c1"># nil since attributes[:name] is nil</span>
<span class="go">=&gt; nil</span>
<span class="gp">&gt;&gt; </span><span class="n">example</span><span class="o">.</span><span class="n">name</span> <span class="o">=</span> <span class="s2">&quot;Example User&quot;</span>           <span class="c1"># Assign a non-nil name</span>
<span class="go">=&gt; &quot;Example User&quot;</span>
<span class="gp">&gt;&gt; </span><span class="n">example</span><span class="o">.</span><span class="n">email</span> <span class="o">=</span> <span class="s2">&quot;user@example.com&quot;</span>      <span class="c1"># and a non-nil email address</span>
<span class="go">=&gt; &quot;user@example.com&quot;</span>
<span class="gp">&gt;&gt; </span><span class="n">example</span><span class="o">.</span><span class="n">formatted_email</span>
<span class="go">=&gt; &quot;Example User &lt;user@example.com&gt;&quot;</span>
</pre></div>
</div>


<p>Here the <code>&rsquo;.&rsquo;</code> is Unix for &ldquo;current directory&rdquo;, and <code>&rsquo;./example_user&rsquo;</code> tells Ruby to look for an example user file relative to that location. The subsequent code creates an empty example user and then fills in the name and email address by assigning directly to the corresponding attributes (assignments made possible by the <code>attr_accessor</code> line in <a class="ref" href="rails-flavored-ruby#code:example_user">extrait&nbsp;4.8</a>). When we write</p>

<div class="code"><div class="highlight"><pre><span class="n">example</span><span class="o">.</span><span class="n">name</span> <span class="o">=</span> <span class="s2">&quot;Example User&quot;</span>
</pre></div>
</div>


<p>Ruby is setting the <code>@name</code> variable to <code>"Example User"</code> (and similarly for the <code>email</code> attribute), which we then use in the <code>formatted_email</code> method.</p>

<p>Recalling from <a class="ref" href="rails-flavored-ruby#sec:css_revisited">section&nbsp;4.3.4</a> we can omit the curly braces for final hash arguments, we can create another user by passing a hash to the <code>initialize</code> method to create a user with pre-defined attributes:</p>

<div class="code"><div class="highlight"><pre><span class="gp">&gt;&gt; </span><span class="n">user</span> <span class="o">=</span> <span class="no">User</span><span class="o">.</span><span class="n">new</span><span class="p">(</span><span class="ss">:name</span> <span class="o">=&gt;</span> <span class="s2">&quot;Michael Hartl&quot;</span><span class="p">,</span> <span class="ss">:email</span> <span class="o">=&gt;</span> <span class="s2">&quot;mhartl@example.com&quot;</span><span class="p">)</span>
<span class="go">=&gt; #&lt;User:0x225167c @email=&quot;mhartl@example.com&quot;, @name=&quot;Michael Hartl&quot;&gt;</span>
<span class="gp">&gt;&gt; </span><span class="n">user</span><span class="o">.</span><span class="n">formatted_email</span>
<span class="go">=&gt; &quot;Michael Hartl &lt;mhartl@example.com&gt;&quot;</span>
</pre></div>
</div>


<p>We will see starting in <a class="ref" href="sign-up#top">chapitre&nbsp;8</a> that initializing objects using a hash argument is common in Rails applications.</p>

<div class="label" id="sec:exercises"></div>


<h2><a id="sec:4.5" href="rails-flavored-ruby#sec:exercises" class="heading"><span class="number">4.5</span> Exercises</a></h2>




<ol>

<li>Using <a class="ref" href="rails-flavored-ruby#code:string_shuffle">extrait&nbsp;4.9</a> as a guide, combine the <code>split</code>, <code>shuffle</code>, and <code>join</code> methods to write a function that shuffles the letters in a given string.</li>

<li>Using <a class="ref" href="rails-flavored-ruby#code:string_shuffle_two">extrait&nbsp;4.10</a> as a guide, add a <code>shuffle</code> method to the <code>String</code> class.</li>

<li>Create three hashes called <code>person1</code>, <code>person2</code>, and <code>person3</code>, with first and last names under the keys <code>:first</code> and <code>:last</code>. Then create a <code>params</code> hash so that <code>params[:father]</code> is <code>person1</code>, <code>params[:mother]</code> is <code>person2</code>, and <code>params[:child]</code> is <code>person3</code>. Verify that, for example, <code>params[:father][:first]</code> has the right value.</li>

<li>Find an online version of the Ruby API and read about the <code>Hash</code> method <code>merge</code>.</li>
</ol>




<div class="label" id="code:string_shuffle"></div>


<div class="codelisting">
<div class="listing"><span class="header">Extrait 4.9.</span> <span class="description">Skeleton for a string shuffle function.</span> </div>
<div class="code"><div class="highlight"><pre><span class="gp">&gt;&gt; </span><span class="k">def</span> <span class="nf">string_shuffle</span><span class="p">(</span><span class="n">s</span><span class="p">)</span>
<span class="gp">&gt;&gt; </span>  <span class="n">s</span><span class="o">.</span><span class="n">split</span><span class="p">(</span><span class="s1">&#39;&#39;</span><span class="p">)</span><span class="o">.</span><span class="sc">?.</span><span class="p">?</span>
<span class="gp">&gt;&gt; </span><span class="k">end</span>
<span class="go">=&gt; nil</span>
<span class="gp">&gt;&gt; </span><span class="n">string_shuffle</span><span class="p">(</span><span class="s2">&quot;foobar&quot;</span><span class="p">)</span>
</pre></div>
</div></div>




<div class="label" id="code:string_shuffle_two"></div>


<div class="codelisting">
<div class="listing"><span class="header">Extrait 4.10.</span> <span class="description">Skeleton for a <code>shuffle</code> method attached to the <code>String</code> class.</span> </div>
<div class="code"><div class="highlight"><pre><span class="gp">&gt;&gt; </span><span class="k">class</span> <span class="nc">String</span>
<span class="gp">&gt;&gt; </span>  <span class="k">def</span> <span class="nf">shuffle</span>
<span class="gp">&gt;&gt; </span>    <span class="nb">self</span><span class="o">.</span><span class="n">split</span><span class="p">(</span><span class="s1">&#39;&#39;</span><span class="p">)</span><span class="o">.</span><span class="sc">?.</span><span class="p">?</span>
<span class="gp">&gt;&gt; </span>  <span class="k">end</span>
<span class="gp">&gt;&gt; </span><span class="k">end</span>
<span class="go">=&gt; nil</span>
<span class="gp">&gt;&gt; </span><span class="s2">&quot;foobar&quot;</span><span class="o">.</span><span class="n">shuffle</span>
</pre></div>
</div></div>




<div class="navigation">  <a class="prev_page" href="static-pages#top">
    &laquo;&nbsp;<span class="number">chapitre 3</span> Mostly static pages
  </a>
  <a class="next_page" href="filling-in-the-layout#top">
    <span class="number">chapitre 5</span> Filling in the layout&nbsp;&raquo;
  </a>
</div><div class="footnotes">
<ol>
<li id="fn:4.1">If a helper is specific to a particular controller, you should put it in the corresponding helper file; for example, helpers for the Pages controller generally go in <code>app/helpers/pages_helper.rb</code>. In our case, we expect the <code>title</code> helper to be used on all the site&rsquo;s pages, and Rails has a special helper file for this case: <code>app/helpers/application_helper.rb</code>.&nbsp;<a class="arrow" href="#fnref:4.1">&uarr;</a></li>
<li id="fn:4.2">I don&rsquo;t provide links to the API because they have a tendency to go out of date quickly. Let Google be your guide. Incidentally, &ldquo;API&rdquo; stands for &ldquo;<a href="http://en.wikipedia.org/wiki/Application_programming_interface">application programming interface</a>&rdquo;.&nbsp;<a class="arrow" href="#fnref:4.2">&uarr;</a></li>
<li id="fn:4.3">If you&rsquo;re impatient, feel free to check out the <a href="http://wiki.github.com/joshuaclayton/blueprint-css/quick-start-tutorial">Blueprint CSS Quickstart tutorial</a>.&nbsp;<a class="arrow" href="#fnref:4.3">&uarr;</a></li>
<li id="fn:4.4">Recall that the console prompt will probably be something like <code>ruby-1.9.2-head &gt;</code>, but the examples use&nbsp;<code>&gt;&gt;</code> since Ruby versions will vary.&nbsp;<a class="arrow" href="#fnref:4.4">&uarr;</a></li>
<li id="fn:4.5">As with the Rails API, Ruby API links go out of date, though not quite as fast. Google is still your guide.&nbsp;<a class="arrow" href="#fnref:4.5">&uarr;</a></li>
<li id="fn:4.6">For more on the origins of &ldquo;foo&rdquo; and &ldquo;bar&rdquo;&mdash;and, in particular, the possible <em>non</em>-relation of &ldquo;foobar&rdquo; to &ldquo;FUBAR&rdquo;&mdash;see the <a href="http://www.catb.org/jargon/html/F/foo.html">Jargon File entry on &ldquo;foo&rdquo;</a>.&nbsp;<a class="arrow" href="#fnref:4.6">&uarr;</a></li>
<li id="fn:4.7">Programmers familiar with Perl or PHP should compare this to the automatic interpolation of dollar sign variables in expressions like <code>"foo $bar"</code>.&nbsp;<a class="arrow" href="#fnref:4.7">&uarr;</a></li>
<li id="fn:4.8">Apologies in advance for switching haphazardly between <em>function</em> and <em>method</em> throughout this chapitre; in Ruby, they&rsquo;re the same thing: all methods are functions, and all functions are methods, because everything is an object.&nbsp;<a class="arrow" href="#fnref:4.8">&uarr;</a></li>
<li id="fn:4.9">Well, there will still be <em>one</em> thing left that we don&rsquo;t understand, which is how Rails ties this all together: mapping URLs to actions, making the <code>title</code> helper available in views, etc. This is an interesting subject, and I encourage you to investigate it further, but knowing exactly <em>how</em> Rails works is not necessary when <em>using</em> Rails. (For a deeper understanding, I recommend <a href="http://www.amazon.com/gp/product/0321601661?ie=UTF8&amp;tag=httpwwwrailst-20&amp;linkCode=as2&amp;camp=1789&amp;creative=390957&amp;creativeASIN=0321601661"><em>The Rails&nbsp;3 Way</em></a> by Obie Fernandez.)&nbsp;<a class="arrow" href="#fnref:4.9">&uarr;</a></li>
<li id="fn:4.10">The <code>second</code> method used here isn&rsquo;t currently part of Ruby itself, but rather is added by Rails. It works in this case because the Rails console automatically includes the Rails extensions to Ruby.&nbsp;<a class="arrow" href="#fnref:4.10">&uarr;</a></li>
<li id="fn:4.11">Programming experts, on the other hand, might benefit from knowing that blocks are <em>closures</em>, which are one-shot anonymous functions with data attached.&nbsp;<a class="arrow" href="#fnref:4.11">&uarr;</a></li>
<li id="fn:4.12">Ruby 1.9 actually guarantees that hashes keep their elements in the same order entered, but it would be unwise ever to count on a particular ordering.&nbsp;<a class="arrow" href="#fnref:4.12">&uarr;</a></li>
<li id="fn:4.13">As a result of having less baggage, symbols are easier to compare to each other; strings need to be compared character by character, while symbols can be compared all in one go. This makes them ideal for use as hash keys.&nbsp;<a class="arrow" href="#fnref:4.13">&uarr;</a></li>
<li id="fn:4.14">You may see some funky numbers, like <code>?1257465942</code>, after the CSS filenames. These are inserted by Rails to ensure that browsers reload the CSS when it changes on the server.&nbsp;<a class="arrow" href="#fnref:4.14">&uarr;</a></li>
<li id="fn:4.15">These results will vary based on the version of Ruby you are using. This example assumes you are using Ruby&nbsp;1.9.2.&nbsp;<a class="arrow" href="#fnref:4.15">&uarr;</a></li>
<li id="fn:4.16">For more on Ruby classes and the <code>self</code> keyword, see the <a href="http://railstips.org/">RailsTips</a> post &ldquo;<a href="http://railstips.org/blog/archives/2006/11/18/class-and-instance-variables-in-ruby/">Class and Instance Variables in Ruby</a>&rdquo;.&nbsp;<a class="arrow" href="#fnref:4.16">&uarr;</a></li>
<li id="fn:4.17">For those familiar with JavaScript, this functionality is comparable to using a intégré class prototype object to augment the class. (Thanks to reader <a href="http://getsatisfaction.com/railstutorial/topics/adding_methods_to_built_in_classes_comparable_to_using_javascripts_prototype_object">Erik Eldridge</a> for pointing this out.)&nbsp;<a class="arrow" href="#fnref:4.17">&uarr;</a></li>
<li id="fn:4.18">You don&rsquo;t have to know what each class in this hierarchy does. <em>I</em> don&rsquo;t know what they all do, and I&rsquo;ve been programming in Ruby on Rails since 2005. This means either that (a) I&rsquo;m grossly incompetent or (b) you can be a skilled Rails developer without knowing all its innards. I hope for both our sakes that it&rsquo;s the latter.&nbsp;<a class="arrow" href="#fnref:4.18">&uarr;</a></li>
</ol>
</div>




